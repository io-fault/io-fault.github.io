[["Channel Processors used to construct conceptual Flows.", "", "A &Channel represents an individual segment in a conceptual Flow. Channels", "connect together like UNIX pipes, but transfer typed messages (objects) instead", "of just data."], ["Signal objects used to communicate flow control operations", "for subflow management. These objects are used by &Catenation and &Division", "to index operations."], ["A Processor consisting of an arbitrary set of operations that", "can connect to other &Channel instances in order to make a series", "of transformations.", "", "Channels are the primary mechanism used to stream events; generally,", "anything that's a stream should be managed by &Channel instances in favor", "of other event callback mechanisms.", "", "[ Properties ]", "", "/f_type/", "\tThe flow type describing what the instance does.", "\tThis property can be &None at the class level, but should be initialized", "\twhen an instance is created.", "", "\t/(id)`source`/", "\t\tChannel that primarily emits independent events for downstream processing.", "\t/(id)`terminal`/", "\t\tChannel processes events, but emits nothing.", "\t/(id)`switch`/", "\t\tChannel that takes events and distributes their transformation", "\t\tto a mapping of receiving flows.", "\t/(id)`join`/", "\t\tChannel that receives events from a set of sources and combines", "\t\tthem into a single stream.", "\t/(id)`transformer`/", "\t\tChannel emits events strictly in response to processing. Transformers", "\t\tmay buffer events as needed.", "\t/&None/", "\t\tUnspecified type.", "", "/f_obstructions/", "\t/&None/", "\t\tNo obstructions present.", "\t/&typing.Mapping/", "\t\tThe objects that are obstructing the &Channel from", "\t\tperforming processing associated with the exact", "\t\tcondition causing it.", "", "/f_monitors/", "\tThe set of callbacks used to signal changes in the flow's", "\t&f_obstructed state.", "", "\t/&None/", "\t\tNo monitors watching the flow state.", "", "/f_downstream/", "\tThe &Channel instance that receives events emitted by the instance", "\tholding the attribute."], ["Connect the Channel to the given object supporting the &Flow interface.", "Normally used with other Channels, but other objects may be connected.", "", "Downstream is *not* notified of upstream obstructions. Events run", "downstream and obstructions run up."], ["Disconnect from the downstream and cease emitting events into &f_downstream."], ["Connect the upstream to the downstream leaving the Channel &self", "in a disconnected state with the old references remaining in place."], ["Reveal the obstructions and monitors of the Channel."], ["Drain the Channel and finish termination by signalling the controller", "of its exit."], ["Termination signal received when the upstream no longer has", "flow transfers for the downstream Channel."], ["Used by subclasses to issue downstream termination and exit.", "", "Subclasses must call this or perform equivalent actions when termination", "of the conceptual flow is complete."], ["Emit the &event directly to the downstream."], ["Method replaced at runtime for selecting the recipient", "of a processed event."], ["Whether the flow is actively performing a transfer.", "", "This property returns &True in cases where the Channel's", "state is such that it may independently send events downstream.", "", "Channels that have buffers *should* implement this method."], ["Whether or not the &Channel is obstructed."], ["Whether or not there are Inexorable obstructions present.", "An integer specifying the number of &Inexorable obstructions or &None", "if there are no obstructions."], ["Instruct the Channel to signal the cessation of transfers.", "The cessation may be permanent depending on the condition."], ["Clear the obstruction by the key given to &obstruction."], ["Assign the given functions as callbacks to obstruction events.", "First called when an obstruction occurs and second when its cleared."], ["Stop watching the Flow's obstructed state."], ["Assigned to &process and &f_emit after termination and interrupt in order", "to keep overruns from exercising the Transformations."], ["Channel dispatching events to the configured callable."], ["Transparent channel that performs a callback when termination", "is received from the upstream channel.", "", "Used as an at-exit callback for flows."], ["Terminal measuring transfer throughput."], ["Archive transfer data occurring before &pit."], ["Relay intersector transfers.", "", "Initialized with the set of events that will be relayed,", "&fe_transfer, &fe_terminate, and &fe_interrupt."], ["Receive intersector transfers.", "", "A simple &Channel expecting to receive events from a remote &Relay"], ["A flow that performs a transformation on the received events."], ["Channel that emits the contents of an &collections.abc.Iterator until", "an obstruction occurs or the iterator ends."], ["Override of &Channel.f_clear that enqueues an &it_transition call", "if it's no longer obstructed."], ["Emit the next item in the iterator until an obstruction occurs or", "the iterator is exhausted."], ["[ Parameters ]", "", "/iterator/", "\tThe iterator that produces events."], ["Raises exception as &Iteration is a source."], ["Terminal &Channel collecting the events into a buffer for processing after", "termination."], ["Construct a &Collection instance that appends all events into a &list."], ["Construct a &Collection instance that extends all events into a &list."], ["Construct a &Collection instance that builds the contents of a", "mapping from sequences of key-value pairs."], ["Construct a &Collection instance that accumulates data from sequences", "of data into a single &bytearray."], ["A dedicated thread for processing events emitted to the Flow.", "", "The requisite function should have the following signature:", "", "#!/pl/python", "\tdef thread_function(transformer, queue, *optional):", "\t\t...", "", "The queue provides access to the events that were received by the Transformer,", "and the &transformer argument allows the thread to cause obstructions by", "accessing its controller."], ["Initiate termination of the thread."], ["Internal; Trap exceptions in order to map them to faults."], ["Send the event to the queue that the Thread is connected to.", "Injections performed by the thread will be enqueued into the main task queue."], ["Execute the dedicated thread for the transformer."], ["Protocol class for containing the state of a protocol layer."], ["Called when the internal protocol state has completed termination.", "", "Defaults to &Channel.f_terminate but overridden in cases where", "synchronization needs to occur with a corresponding Protocol channel."], ["Perform an empty transfer allowing any transmit buffers to be emptied."], ["Sequence a set of flows in the enqueued order.", "", "Emulates parallel operation by facilitating the sequenced delivery of", "a sequence of flows where the first flow is carried until completion before", "the following flow may be processed.", "", "Essentially, this is a buffer array that uses Flow termination signals", "to manage the current working flow and queues to buffer the events to be emitted", "when next is promoted.", "", "[ Engineering ]", "/notes/", "\tSubjected to a number of adjustments, there may be a few reductions", "\tthat can be performed without impacting functionality.", "/Untested/", "\t- Recursive transition() calls.", "", "[ Properties ]", "", "/cat_order/", "\tQueue of channels dictating the order of the flows.", "/cat_connections/", "\tMapping of connected &Flow instances to their corresponding", "\tqueue, &Layer, and termination state.", "/cat_flows/", "\tChannel identifier associated with weak reference to upstream."], ["Whether the given flow's queue has too many items."], ["Emit point for Sequenced Flows"], ["Connect the flow to the &channel_id using the &initiate parameter."], ["Reserve a position in the sequencing of the flows. The given &initiate is the reference", "object used by &int_connect in order to actually connect flows."], ["Transparency support allowing &Division to be directly connected.", "Usually unused."], ["Termination signal ignored. Flow state dictates terminal state."], ["Flush the accumulated events downstream."], ["Drain the new head of line emitting any queued events and", "updating its entry in &cat_connections to immediately send events."], ["Move the first enqueued flow to the front of the line;", "flush out the buffer and remove ourselves as an obstruction."], ["Coordination of the routing of a protocol's content.", "", "Protocols consisting of a series of requests, HTTP for instance,", "need to control where the content of a request goes. &QueueProtocolInput", "manages the connections to actual &Flow instances that delivers", "the transformed application level events."], ["Direct the given events to their corresponding action in order to", "map protocol stream events to &Flow instances."], ["Interruptions on distributions translates to termination."], ["Initiate a subflow using the given &channel_id as its identity.", "The &channel_id along with a callable performing &div_connect will be emitted", "to the &Flow.f_connect downstream."], ["Associate the &flow with the &channel_id allowing transfers into the flow.", "", "Drains the queue that was collecting events associated with the &channel_id,", "and feeds them into the flow before destroying the queue. Layer connections", "without queues are the head of the line, and actively receiving transfers", "and control events."], ["Enqueue or transfer the events to the flow associated with the channel_id context."], ["End of subflow."]]