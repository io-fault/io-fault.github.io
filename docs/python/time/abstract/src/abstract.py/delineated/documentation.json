[["Abstract base classes for time measures and points.", "", "Primarily, this module exists to document the interfaces to &Point and &Measure.", "The redundant method declarations are intentional."], ["The abstract base class for *all* Time related types."], ["The beginning of the range. Inclusive."], ["The end of the range. Exclusive."], ["The size of the range in terms of the &start."], ["Whether the given point falls between &start, inclusive, and &stop, exclusive.", "", "#!python", "\tassert self.start >= pit and pit < self.stop"], ["Create an instance of the type from the sum of the quantities", "specified by &times and &parts:", "", "#!python", "\tt = Time.of(hour = 33, microsecond = 44)", "", "The above example only shows keyword use that is specific to the standard", "time context used by &..time. Variable position arguments, &times,", "must be pre-existing &Measure instances.", "", "[ Parameters ]", "/times/", "\tA sequence of &Time instances.", "/parts/", "\tKeyword names designate the unit of the corresponding value.", "\tThe time context dictates what that is."], ["Extract the number of complete parts designated by `part` after the last", "complete whole, `of`, with respect to the alignment, `align`.", "", "The result is an &int or an arbitrary object given that", "a Container part is referenced.", "", "Common cases:", "", "#!python", "\th = x.select('hour', 'day')", "\tm = x.select('minute', 'hour')", "\ts = x.select('second', 'minute')", "\tu = x.select('microsecond', 'second')", "", "[ Parameters ]", "/part/", "\tThe unit whose count is to be returned.", "/of/", "\tThe unit whose total wholes are subtracted", "\tfrom `self` in order to find the correct total parts.", "/align/", "\tHow to align the given part.", "\tTrivially, this is a difference that is applied", "\tprior to removing wholes: `value = self - align`."], ["Construct and return a new instance adjusted by the difference between the", "selected part and the given value with respect to the specified alignment.", "", "The following holds true:", "", "#!python", "\tupdated = pit.update(part, replacement, of, align)", "\tadjusted = this.adjust(**{part: replacement - pit.select(part, of, align)})", "\tassert updated == adjusted", "", "It's existence as an interface is due to its utility.", "", "[ Parameters ]", "/part/", "\tThe name of the Part unit to set.", "/replacement/", "\tThe new value to set.", "/of/", "\tThe name of the Whole unit that defines the boundary of the part.", "/align/", "\tDefaults to zero; the adjustment applied to the boundary."], ["Truncates the time instance to the specified boundary: remove units smaller", "than the given &unit.", "", "[ Parameters ]", "/unit/", "\tThe minimum unit size to allow in the new time instance."], ["An abstract quantity time. Usually, identified as a Scalar quantity unless", "subclassed."], ["Classification for the unit type with respect to measurements.", "", "Currently, only three kinds exist: definite, subjective, and indefinite.", "", "Measures and Points of the same unit may have different unit kinds."], ["Identifier of the unit of time--usually the english name.", "", "This *must* be a `str` where str(unit).isidentifier() is `True`."], ["Name of the unit of time. Normally equal to", "&Time.unit, but potentially different in cases", "where the proper name is not an identifier."], ["For Measure instances, this property *must* be zero.", "", "#!python", "\tassert measure.start == 0"], ["For Measure instances, this property *must* be the instance, &self:", "", "#!python", "\tassert measure.stop is measure"], ["The magnitude of the Time instance. For Measures, this is their integer value:", "", "#!python", "\tassert int(measure) == measure.magnitude"], ["Increase the measurement, repositioning the &stop.", "", "Returns a new Measure instance whose value is `self` increased by", "the given parameters.", "", "This is equivalent to:", "", "#!python", "\tassert self.increase(*units, **parts) == self.of(self, *units, **parts)", "", "[ Parameters ]", "/units/", "\tVariable number of &Measure instances.", "/parts/", "\tVariable keywords whose keys designate the unit."], ["Decrease the measurement, repositioning the &stop.", "", "Returns a new Measure instance whose value is `self` decreased by", "the given parameters.", "", "This is equivalent to:", "", "#!python", "\tneg_units = [-unit for unit in units]", "\tneg_parts = {k:-v for (k,v) in parts}", "", "\tassert self.decrease(*units, **parts) == self.of(self, *neg_units, **neg_parts)", "", "[ Parameters ]", "/units/", "\tVariable number of &Measure instances.", "/parts/", "\tVariable keywords whose keys designate the unit."], ["A point in time."], ["Classification for the unit type with respect to Points in Time."], ["The Point's corresponding scalar class used to measure deltas.", "This provides access to a &.abstract.Measure whose precision is consistent with the &Point.", "", "[ Invariants ]", "#!python", "\tassert point.Measure.unit == point.unit"], ["Points *must* return the instance, &self:", "", "[ Invariants ]", "#!python", "\tassert point.start is point"], ["The next Point according to the unit:", "", "[ Invariants ]", "#!python", "\tassert point.stop == point.elapse(point.Measure(1))"], ["The magnitude of the Point. For Points, this *must* be one:", "", "#!python", "\tassert pit.magnitude == 1"], ["Return the measurement, &Measure instance, between &self and", "the given point in time, &pit. The delta between the two points."], ["Returns an adjusted measure in time by the given arguments and keywords.", "", "Essentially, this is a call to the &of", "method with the instance as the first parameter.", "", "This is shorthand for `t.of(t, *units, **parts)`."], ["The point in time that occurred the given number of units before this", "point. The semantics are identical to &Point.elapse, but transforms", "the parameters into negative values.", "", "[ Invariants ]", "#!python", "\tpit == (pit.rollback(*measures, **units)).elapse(*measures, **units)"], ["Returns whether or not the Point in Time, self,", "comes *before* the given argument, &pit."], ["Returns whether or not the Point in Time, self,", "comes *after* the given argument, &pit."]]