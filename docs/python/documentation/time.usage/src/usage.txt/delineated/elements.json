["factor", [["chapter", [["section", [["paragraph", ["Units of unbound quantities of time are called \"eternals\". They are a special Measure and", " ", "Point type that have only three values: zero, infinity, and negative infinity."], {"indentation": null}], ["paragraph", ["Time classes are created by Time Contexts. The default context is", " ", "initialized and provided by the ", ["reference", [".types"], {"source": ".types", "type": "normal", "action": null, "cast": null, "url": null}], " module. The following", " ", "lists are the time classes created by that context."], {"indentation": null}], ["paragraph", ["Point In Time types:"], {"indentation": null}], ["set", [["item", [["paragraph", ["", ["reference", [".types.Timestamp"], {"source": ".types.Timestamp", "type": "normal", "action": null, "cast": null, "url": null}], ""], {"indentation": null}]], {}], ["item", [["paragraph", ["", ["reference", [".types.Date"], {"source": ".types.Date", "type": "normal", "action": null, "cast": null, "url": null}], ""], {"indentation": null}]], {}], ["item", [["paragraph", ["", ["reference", [".types.Week"], {"source": ".types.Week", "type": "normal", "action": null, "cast": null, "url": null}], ""], {"indentation": null}]], {}], ["item", [["paragraph", ["", ["reference", [".types.GregorianMonth"], {"source": ".types.GregorianMonth", "type": "normal", "action": null, "cast": null, "url": null}], ""], {"indentation": null}]], {}]], {}], ["paragraph", ["Measure types:"], {"indentation": 0}], ["set", [["item", [["paragraph", ["", ["reference", [".types.Measure"], {"source": ".types.Measure", "type": "normal", "action": null, "cast": null, "url": null}], ""], {"indentation": null}]], {}], ["item", [["paragraph", ["", ["reference", [".types.Days"], {"source": ".types.Days", "type": "normal", "action": null, "cast": null, "url": null}], ""], {"indentation": null}]], {}], ["item", [["paragraph", ["", ["reference", [".types.Weeks"], {"source": ".types.Weeks", "type": "normal", "action": null, "cast": null, "url": null}], ""], {"indentation": null}]], {}], ["item", [["paragraph", ["", ["reference", [".types.Months"], {"source": ".types.Months", "type": "normal", "action": null, "cast": null, "url": null}], ""], {"indentation": null}]], {}]], {}], ["paragraph", ["The interfaces are described by the abstract base classes in", " ", "", ["reference", [".abstract"], {"source": ".abstract", "type": "normal", "action": null, "cast": null, "url": null}], ". Primarily:"], {"indentation": 0}], ["directory", [["item", [["key", ["", ["reference", [".abstract.Time"], {"source": ".abstract.Time", "type": "normal", "action": null, "cast": null, "url": null}], ""], {}], ["value", [["paragraph", ["A measure or point. The common abstract base class."], {"indentation": 1}]], {}]], {"identifier": "\u2219abstract\u2219Time"}], ["item", [["key", ["", ["reference", [".abstract.Measure"], {"source": ".abstract.Measure", "type": "normal", "action": null, "cast": null, "url": null}], ""], {}], ["value", [["paragraph", ["A measurement of time."], {"indentation": 1}]], {}]], {"identifier": "\u2219abstract\u2219Measure"}], ["item", [["key", ["", ["reference", [".abstract.Point"], {"source": ".abstract.Point", "type": "normal", "action": null, "cast": null, "url": null}], ""], {}], ["value", [["paragraph", ["A point in time. Points are used to specify calendar dates or", " ", "calendar dates with time of day."], {"indentation": 1}]], {}]], {"identifier": "\u2219abstract\u2219Point"}]], {}]], {"identifier": "Overview", "absolute": ["Overview"], "selector-path": ["Overview"], "selector-level": null, "selector-multiple": null}], ["section", [["section", [["paragraph", ["This has the effect that integers with the same value will be seen as the same", " ", "key in dictionaries:"], {"indentation": null}], ["syntax", [["line", [">>> from fault.time import types"], {}], ["line", [">>> from fault.time import constants"], {}], ["line", [">>> d = {}"], {}], ["line", [">>> d[types.Date(0)] = 'Hello, World!'"], {}], ["line", [">>> print d[0]"], {}], ["line", ["Hello, World!"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["If type based scoping is needed, the key can be qualified with the type:"], {"indentation": 0}], ["syntax", [["line", ["d = {}"], {}], ["line", ["d[(types.Date, types.Date(0))] = 'date-value'"], {}], ["line", ["d[(types.Timestamp, types.Timestamp(0))] = 'timestamp-value'"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Or, nested dictionaries could be used:"], {"indentation": 0}], ["syntax", [["line", ["d = {types.Date: {}, types.Timestamp: {}}"], {}], ["line", ["d[types.Date][types.Date(0))] = 'date-value'"], {}], ["line", ["d[types.Timestamp][types.Timestamp(0))] = 'timestamp-value'"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Points and Measures are Python Integers", "absolute": ["Eccentricities", "Points and Measures are Python Integers"], "selector-path": ["Points and Measures are Python Integers"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], " is heavily based on direct Python ", ["reference", ["int"], {"source": "int", "type": "normal", "action": null, "cast": null, "url": null}], " subclasses. This offers many", " ", "benefits, but it also avoids overriding the integer's operators leaving a,", " ", "contextually, low-level operation that should normally be avoided. This likely", " ", "offers a suprise as the usual addition (", ["literal", ["+"], {"cast": null}], ") and subtraction (", ["literal", ["-"], {"cast": null}], ") operators", " ", "do not perform as they would with the standard library's ", ["reference", ["datetime.datetime"], {"source": "datetime.datetime", "type": "normal", "action": null, "cast": null, "url": null}], "", " ", "or many other datetime packages."], {"indentation": null}], ["paragraph", ["Instead, ", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], " relies on the higher-level methods to perform delta", " ", "calculation and point positioning."], {"indentation": null}]], {"identifier": "Datetime Math", "absolute": ["Eccentricities", "Datetime Math"], "selector-path": ["Datetime Math"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["The ", ["literal", ["day"], {"cast": null}], " and ", ["literal", ["month"], {"cast": null}], " fields of the standard time context are ", ["emphasis", ["offsets"], {"weight": "2"}], " and", " ", "are not consistent with the usual representation of gregorian day-of-month and", " ", "month-of-year. Some of the Container keywords do, however, use the usual", " ", "gregorian representation."], {"indentation": null}], ["paragraph", ["More clearly:"], {"indentation": null}], ["syntax", [["line", ["pit = types.Timestamp.of(iso=\"2002-01-01T00:00:00\")"], {}], ["line", ["assert pit.select('day', 'month') == 0"], {}], ["line", ["assert pit.select('month', 'year') == 0"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["As opposed to the day-of-month and month-of-year fields being equal to ", ["literal", ["1"], {"cast": null}], " as", " ", "one might expect them to be. Rather, ", ["emphasis", ["they are offsets"], {"weight": "1"}], "."], {"indentation": 0}]], {"identifier": "Day and Month Fields", "absolute": ["Eccentricities", "Day and Month Fields"], "selector-path": ["Day and Month Fields"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["The implementation of month arithmetic is sensitive to the selected day:"], {"indentation": null}], ["syntax", [["line", ["# working with a leap year"], {}], ["line", ["pit = types.Timestamp.of(iso='2012-01-31T18:55:33.946259')"], {}], ["line", ["pit.elapse(month=1)"], {}], ["line", ["types.Timestamp.of(iso='2012-03-02T18:55:33.946259')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["The issue can be avoided by adjusting the PiT to the beginning of the month:"], {"indentation": 0}], ["syntax", [["line", ["pit = pit.update('day', 0, 'month')"], {}], ["line", ["pit.elapse(month=1)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Month Arithmetic Can Overflow", "absolute": ["Eccentricities", "Month Arithmetic Can Overflow"], "selector-path": ["Month Arithmetic Can Overflow"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["The \"year\" unit in ", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], " is strictly referring to gregorian years. This means", " ", "that a \"year\" in ", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], " is actually twelve gregorian months, which means", " ", "", ["emphasis", ["years are a subjective unit of time"], {"weight": "1"}], ".", " ", "For ", ["emphasis", ["metric"], {"weight": "1"}], " measures--Python timedeltas analog--this", " ", "poses a problem in that years should not be used to represent the span when working", " ", "with ", ["reference", [".types.Measure"], {"source": ".types.Measure", "type": "normal", "action": null, "cast": null, "url": null}], "."], {"indentation": null}], ["paragraph", ["In order to compensate, the ", ["reference", [".types.Month"], {"source": ".types.Month", "type": "normal", "action": null, "cast": null, "url": null}], " class provides a means to", " ", "express such subjective time spans."], {"indentation": null}]], {"identifier": "Annums and Years", "absolute": ["Eccentricities", "Annums and Years"], "selector-path": ["Annums and Years"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["Unit subclasses do ", ["emphasis", ["not"], {"weight": "1"}], " override the built-in comparison methods implemented by the", " ", "", ["reference", ["int"], {"source": "int", "type": "normal", "action": null, "cast": null, "url": null}], " type that all unit classes are based on. Given that these classes can", " ", "represent different units, comparisons ", ["emphasis", ["must"], {"weight": "1"}], " be performed with ", ["emphasis", ["like units"], {"weight": "1"}], " in order", " ", "to yield consistently correct results. In order to compensate, unit aware comparisons are", " ", "provided for ", ["reference", [".abstract.Point"], {"source": ".abstract.Point", "type": "normal", "action": null, "cast": null, "url": null}], " types:", " ", "", ["reference", [".abstract.Point.leads"], {"source": ".abstract.Point.leads", "type": "normal", "action": null, "cast": null, "url": null}], " and ", ["reference", [".abstract.Point.follows"], {"source": ".abstract.Point.follows", "type": "normal", "action": null, "cast": null, "url": null}], "."], {"indentation": null}], ["paragraph", ["Measures do not implement unit-aware comparisons and must be converted to like-units", " ", "before the integer comparisons may be used."], {"indentation": null}]], {"identifier": "Unit Aware Comparison", "absolute": ["Eccentricities", "Unit Aware Comparison"], "selector-path": ["Unit Aware Comparison"], "selector-level": 1, "selector-multiple": null}]], {"identifier": "Eccentricities", "absolute": ["Eccentricities"], "selector-path": ["Eccentricities"], "selector-level": null, "selector-multiple": null}], ["section", [["paragraph", ["", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], " does not use the usual arithmetic operators for performing datetime", " ", "math. Rather, ", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], " ", ["emphasis", ["uses named methods in order to draw a semantic distinction"], {"weight": "1"}], ".", " ", "Not to mention, it is sometimes desirable to use the integer's operators directly", " ", "in order to avoid semantics involved with representation types."], {"indentation": null}], ["paragraph", ["The list here points to the abstract base classes.", " ", "Points ", ["emphasis", ["are"], {"weight": "1"}], " timestamps, datetimes,. Measures ", ["emphasis", ["are"], {"weight": "1"}], " intervals, timedeltas."], {"indentation": null}], ["directory", [["item", [["key", ["", ["literal", ["timedelta() + timedelta()"], {"cast": null}], ""], {}], ["value", [["paragraph", ["", ["reference", [".abstract.Measure.increase"], {"source": ".abstract.Measure.increase", "type": "normal", "action": null, "cast": null, "url": null}], ":"], {"indentation": 1}], ["syntax", [["line", ["m1 = types.Measure(second=0)"], {}], ["line", ["m2 = types.Measure(second=1)"], {}], ["line", ["d = m1.increase(m2)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {}]], {"identifier": "timedelta() + timedelta()"}], ["item", [["key", ["", ["literal", ["timedelta() - timedelta()"], {"cast": null}], ""], {}], ["value", [["paragraph", ["", ["reference", [".abstract.Measure.decrease"], {"source": ".abstract.Measure.decrease", "type": "normal", "action": null, "cast": null, "url": null}], ":"], {"indentation": 1}], ["syntax", [["line", ["m1 = types.Measure(second=2)"], {}], ["line", ["m2 = types.Measure(second=1)"], {}], ["line", ["d = m1.decrease(m2)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {}]], {"identifier": "timedelta() - timedelta()"}], ["item", [["key", ["", ["literal", ["datetime() + timedelta()"], {"cast": null}], ""], {}], ["value", [["paragraph", ["", ["reference", [".abstract.Point.elapse"], {"source": ".abstract.Point.elapse", "type": "normal", "action": null, "cast": null, "url": null}], ":"], {"indentation": 1}], ["syntax", [["line", ["ts = types.Timestamp.of(...)"], {}], ["line", ["measure = types.Measure(second=1)"], {}], ["line", ["d = ts.elapse(measure)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {}]], {"identifier": "datetime() + timedelta()"}], ["item", [["key", ["", ["literal", ["datetime() - timedelta()"], {"cast": null}], ""], {}], ["value", [["paragraph", ["Point in Time subtraction is handled with", " ", "", ["reference", [".abstract.Point.rollback"], {"source": ".abstract.Point.rollback", "type": "normal", "action": null, "cast": null, "url": null}], ":"], {"indentation": 1}], ["syntax", [["line", ["ts = types.Timestamp.of()"], {}], ["line", ["measure = types.Measure(second=1)"], {}], ["line", ["d = ts.rollback(measure)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {}]], {"identifier": "datetime() - timedelta()"}], ["item", [["key", ["", ["literal", ["datetime() - datetime()"], {"cast": null}], ""], {}], ["value", [["paragraph", ["", ["reference", [".abstract.Point.measure"], {"source": ".abstract.Point.measure", "type": "normal", "action": null, "cast": null, "url": null}], ":"], {"indentation": 1}], ["syntax", [["line", ["ts1 = types.Timestamp.of(...)"], {}], ["line", ["ts2 = types.Timestamp.of(...)"], {}], ["line", ["d = ts1.measure(ts2) # measure the distance between"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {}]], {"identifier": "datetime() - datetime()"}]], {}]], {"identifier": "Math in Python datetime Terms", "absolute": ["Math in Python datetime Terms"], "selector-path": ["Math in Python datetime Terms"], "selector-level": null, "selector-multiple": null}], ["section", [["paragraph", ["A Date can be used to represent the span of the entire day."], {"indentation": null}], ["syntax", [["line", ["date = types.Date.of(year=1982, month=4, day=17)"], {}], ["line", ["assert date.select('day', 'month') == 17"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["However, the above actually represents."], {"indentation": 0}], ["syntax", [["line", ["assert date.select('date') == (1982, 5, 18)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Usually, using the ", ["literal", ["date"], {"cast": null}], " keyword is best way to to work with", " ", "literal dates."], {"indentation": 0}], ["syntax", [["line", ["assert types.Date.of(date=(1982,5,18)) == date"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["The calendrical ", ["emphasis", ["representation"], {"weight": "2"}], " only takes effect through certain", " ", "interfaces."], {"indentation": 0}], ["syntax", [["line", ["ts = types.Timestamp.of(iso=\"2001-01-01T05:30:01\")"], {}], ["line", ["print(repr(ts))"], {}], ["line", ["types.Timestamp.of(iso='2001-01-01T05:30:01.000000')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["And from a datetime tuple."], {"indentation": 0}], ["syntax", [["line", ["ts2 = types.Timestamp.of(datetime = (2001, 1, 1, 5, 30, 1, 0))"], {}], ["line", ["assert ts == ts2"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], " PiTs do not perform calendrical validation; rather, fields with excess", " ", "values overflow onto larger units. This is similar to how MySQL handles", " ", "overflow. For ", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], ", this choice is deliberate and the user is expected to", " ", "perform any desired validation."], {"indentation": 0}], ["syntax", [["line", ["pit = types.Date.of(date=(1982,5,0))"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["The assigned ", ["literal", ["pit"], {"cast": null}], " now points to the last day of the month preceding the fifth", " ", "month in the year 1982."], {"indentation": 0}]], {"identifier": "Calendar Representation", "absolute": ["Calendar Representation"], "selector-path": ["Calendar Representation"], "selector-level": null, "selector-multiple": null}], ["section", [["paragraph", ["", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], " can easily answer questions like, \"What was third weekend of the fifth", " ", "month of last year?\"."], {"indentation": null}], ["syntax", [["line", ["pit = system.utc()"], {}], ["line", ["pit = pit.update('day', 0, 'month') # set to the first day to avoid overflow"], {}], ["line", ["pit = pit.rollback(year=1) # subtract one gregorian year"], {}], ["line", ["pit = pit.update('month', 5-1, 'year') # set to the fifth month"], {}], ["line", ["pit = pit.update('day', 6, 'week') # set to the weekend of the week"], {}], ["line", ["pit = pit.elapse(week = 2)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Things can get a little more interesting when asking about the last weekend", " ", "of a given month."], {"indentation": 0}], ["syntax", [["line", ["# move the beginning of month (to avoid possible day overflow)"], {}], ["line", ["pit = system.utc().update('day', 0, 'month')"], {}], ["line", ["# to the next month and then to the end of the previous"], {}], ["line", ["pit = pit.elapse(month = 1).update('day', -1, 'month') # move to the end of the month."], {}], ["line", ["# 0 is the beginning of the week, so -1 is the end of the prior week."], {}], ["line", ["pit = pit.update('day', -1, 'week')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["On day overflow, the following illustrates the effect:"], {"indentation": 0}], ["syntax", [["line", ["# working with a leap year"], {}], ["line", ["pit = types.Timestamp.of(iso='2012-01-31T18:55:33.946259')"], {}], ["line", ["pit.elapse(month=1)"], {}], ["line", ["types.Timestamp.of(iso='2012-03-02T18:55:33.946259')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Month arithmetic does not lose days in order to align the edge of a month.", " ", "In order to keep overflow from causing invalid calculations, adjust to the", " ", "beginning of the month."], {"indentation": 0}], ["paragraph", ["Things can get even more interesting when asking,", " ", "\"What is the second to last Thursday of the month\". Questions like this require", " ", "alignment in order to be answered:"], {"indentation": null}], ["syntax", [["line", ["pit = system.utc()"], {}], ["line", ["pit = pit.update('day', 0, 'month') # let's say this month"], {}], ["line", ["# but we need the end of the month"], {}], ["line", ["pit = pit.elapse(month=1)"], {}], ["line", ["pit = pit.update('day', -1, 'month') # set to the first day"], {}], ["line", ["# And now something that will appear almost magical if"], {}], ["line", ["# you haven't used a datetime package with a similar feature."], {}], ["line", ["pit = pit.update('day', 0, 'week', align=-4) # last thursday of month"], {}], ["line", ["pit = pit.rollback(week=1) # second to last"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Essentially, alignment allows Thursdays to be seen as the first day of the", " ", "week, warranting that the day field will stay the same or be subtracted when", " ", "set to zero. This is why the day is set to the last day of the month, in case", " ", "the Thursday is the last day of the month, and with proper alignment the first", " ", "day of the re-aligned week."], {"indentation": 0}]], {"identifier": "Datetime Math", "absolute": ["Datetime Math"], "selector-path": ["Datetime Math"], "selector-level": null, "selector-multiple": null}], ["section", [["paragraph", ["Time zone adjustments are supported by zone objects:"], {"indentation": null}], ["syntax", [["line", ["pit = system.utc()"], {}], ["line", ["tz = views.Zone.open('America/Los_Angeles')"], {}], ["line", ["local_pit = tz.localize(pit)"], {}], ["line", ["print(local_pit.select('iso'))"], {}], ["line", [""], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Time Zones", "absolute": ["Time Zones"], "selector-path": ["Time Zones"], "selector-level": null, "selector-multiple": null}], ["section", [["paragraph", ["A Point is a Point in Time; like a date or a date and time of day. Usually, this", " ", "is referring to instances of the ", ["reference", [".types.Timestamp"], {"source": ".types.Timestamp", "type": "normal", "action": null, "cast": null, "url": null}], " class. A Measure", " ", "is an arbitrary unit of time and is usually referring to instances the", " ", "", ["reference", [".types.Measure"], {"source": ".types.Measure", "type": "normal", "action": null, "cast": null, "url": null}], " class."], {"indentation": null}], ["paragraph", ["Constructing instances is usually performed with the class method", " ", "", ["reference", [".types.Measure.of"], {"source": ".types.Measure.of", "type": "normal", "action": null, "cast": null, "url": null}], ". Or, ", ["reference", [".types.Timestamp.of"], {"source": ".types.Timestamp.of", "type": "normal", "action": null, "cast": null, "url": null}], " for Points."], {"indentation": null}], ["section", [["paragraph", ["The ", ["reference", [".types.Timestamp"], {"source": ".types.Timestamp", "type": "normal", "action": null, "cast": null, "url": null}], " type is the Point In Time Representation", " ", "Type with the finest precision available ", ["emphasis", ["by default"], {"weight": "1"}], ":"], {"indentation": null}], ["syntax", [["line", ["near_y2k = types.Timestamp.of(date=(2000,1,1), hour=8, minute=24, second=15)"], {}], ["line", [">>> near_y2k"], {}], ["line", ["types.Timestamp.of(iso='2000-01-01T08:24:15.000000')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Currently, The ", ["reference", [".types.Timestamp"], {"source": ".types.Timestamp", "type": "normal", "action": null, "cast": null, "url": null}], " and ", ["reference", [".types.Measure"], {"source": ".types.Measure", "type": "normal", "action": null, "cast": null, "url": null}], " types use nanosecond precision."], {"indentation": 0}]], {"identifier": "Creating a Timestamp", "absolute": ["Constructing Points and Measures", "Creating a Timestamp"], "selector-path": ["Creating a Timestamp"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["A Date is also considered a Point In Time type. The Date type exists for the", " ", "purpose of representing the point in which the specified day starts, ", ["emphasis", ["and"], {"weight": "1"}], " the", " ", "period between that point and the start of the next day; non-inclusive:"], {"indentation": null}], ["syntax", [["line", ["types.Date.of(year=1982, month=4, day=17) # month and day are offsets."], {}], ["line", ["types.Date.of(iso='1982-05-18')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["While a little suprising, the above reveals an apparent inconsistency: the", " ", "", ["literal", ["month"], {"cast": null}], " keyword parameter acts as a month offset. To compensate,", " ", "the ", ["literal", ["date"], {"cast": null}], " container keyword parameter is treated specially to accept", " ", "gregorian calendar representation. The keyword parameters are literal", " ", "increments of units. Subsequently, using the ", ["literal", ["date"], {"cast": null}], " container can more", " ", "appropriate:"], {"indentation": 0}], ["syntax", [["line", [">>> types.Date.of(date=(1982,5,18))"], {}], ["line", ["types.Date.of(iso='1982-05-18')"], {}], ["line", [""], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Creating a Date", "absolute": ["Constructing Points and Measures", "Creating a Date"], "selector-path": ["Creating a Date"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["The primary interface for accessing the system clock is using the", " ", "", ["reference", [".system.utc"], {"source": ".system.utc", "type": "normal", "action": null, "cast": null, "url": null}], " callable:"], {"indentation": null}], ["syntax", [["line", ["current_time = system.utc()"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["The returned timestamp is a UTC timestamp."], {"indentation": 0}]], {"identifier": "Getting the Current Point in Time", "absolute": ["Constructing Points and Measures", "Getting the Current Point in Time"], "selector-path": ["Getting the Current Point in Time"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["While the ", ["reference", [".format"], {"source": ".format", "type": "normal", "action": null, "cast": null, "url": null}], " module manages the details, the", " ", "types have access to the functionality:"], {"indentation": null}], ["syntax", [["line", ["ts = types.Timestamp.of(iso='2009-02-01T3:33:45.123321')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["", ["reference", ["..time"], {"source": "..time", "type": "normal", "action": null, "cast": null, "url": null}], " provides parsers for both ISO-8601 and RFC-1123 datetime formats. The", " ", "above example shows how to construct a Point in Time from an ISO-8601 string.", " ", "The following shows RFC-1123, the format used by HTTP:"], {"indentation": 0}], ["syntax", [["line", ["ts = types.Timestamp.of(rfc='Sun, 19 Mar 2012 07:27:58')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Creating a Timestamp from an ISO-8601 String", "absolute": ["Constructing Points and Measures", "Creating a Timestamp from an ISO-8601 String"], "selector-path": ["Creating a Timestamp from an ISO-8601 String"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["Likewise, instances can be formatted by the standards:"], {"indentation": null}], ["syntax", [["line", ["ts = types.Timestamp.of(iso='2009-01-01T7:30:0')"], {}], ["line", ["print(ts.select('iso'))"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["And RFC as well:"], {"indentation": 0}], ["syntax", [["line", ["assert \"Sat, 01 Jan 2000 00:00:00\" == types.Timestamp(date=(2000,1,1)).select('rfc')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Formatting a Standard Timestamp", "absolute": ["Constructing Points and Measures", "Formatting a Standard Timestamp"], "selector-path": ["Formatting a Standard Timestamp"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["A ", ["reference", [".types.Timestamp"], {"source": ".types.Timestamp", "type": "normal", "action": null, "cast": null, "url": null}], " can be constructed from time parts using the", " ", "", ["reference", [".abstract.Time.of"], {"source": ".abstract.Time.of", "type": "normal", "action": null, "cast": null, "url": null}], " class method. This method takes", " ", "arbitrary positional parameters and keyword parameters whose keys are the name", " ", "of a unit of time known by the time context:"], {"indentation": null}], ["syntax", [["line", ["ts = types.Timestamp.of(hour = 55, second = 78)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Notably, the above is not particularly useful without a date:"], {"indentation": 0}], ["syntax", [["line", ["types.Timestamp.of("], {}], ["line", ["\tdate = (2015, 1, 1),"], {}], ["line", ["\thour = 13, minute = 7,"], {}], ["line", ["\tsecond = 4,"], {}], ["line", ["\tmicrosecond = 324159"], {}], ["line", [")"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Constructing a Timestamp from Parts", "absolute": ["Constructing Points and Measures", "Constructing a Timestamp from Parts"], "selector-path": ["Constructing a Timestamp from Parts"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["The ", ["literal", ["unix"], {"cast": null}], " container keyword provides an interface from seconds since the", " ", "UNIX-epoch, \"January 1, 1970\". A timestamp can be made using the", " ", "", ["reference", [".abstract.Time.of"], {"source": ".abstract.Time.of", "type": "normal", "action": null, "cast": null, "url": null}], " method:"], {"indentation": null}], ["syntax", [["line", ["epoch = types.Timestamp.of(unix=0)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Subseqently, a given PiT can yield a UNIX timestamp using the", " ", "", ["reference", [".abstract.Time.select"], {"source": ".abstract.Time.select", "type": "normal", "action": null, "cast": null, "url": null}], " method:"], {"indentation": 0}], ["syntax", [["line", ["now = system.utc()"], {}], ["line", ["unix = now.select('unix')"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["And a contrived use-case where the file ", ["literal", ["f"], {"cast": null}], " contains lines containing unix timestamps:"], {"indentation": 0}], ["syntax", [["line", ["with open(...) as f:"], {}], ["line", ["\ttimes = list(map(from_unix, map(int, f.readlines())))"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Constructing a Timestamp from a UNIX Timestamp", "absolute": ["Constructing Points and Measures", "Constructing a Timestamp from a UNIX Timestamp"], "selector-path": ["Constructing a Timestamp from a UNIX Timestamp"], "selector-level": 1, "selector-multiple": null}]], {"identifier": "Constructing Points and Measures", "absolute": ["Constructing Points and Measures"], "selector-path": ["Constructing Points and Measures"], "selector-level": null, "selector-multiple": null}], ["section", [["paragraph", ["Time types are all based on subclasses of Python's ", ["reference", ["int"], {"source": "int", "type": "normal", "action": null, "cast": null, "url": null}], ".", " ", "The usual arithmetic operators are essentially low-level operations that can be", " ", "used in certain cases, but they should be restricted to performance critical", " ", "situations where the higher-level methods cannot be used."], {"indentation": null}], ["section", [["paragraph", ["Points and scalars can both update arbitrary fields according to a boundary.", " ", "With Timestamps and Dates aligned on the beginning of a week, an arbitrary", " ", "day of week can be found by field modification:"], {"indentation": null}], ["syntax", [["line", ["ts = types.Timestamp.of(iso=\"2000-01-01T3:30:00\")"], {}], ["line", [">>> print(ts.select('day', 'week'))"], {}], ["line", ["6"], {}], ["line", ["ts = ts.update('day', 1, 'week') # 0-6, Sun-Sat."], {}], ["line", [">>> print(ts)"], {}], ["line", ["'1999-12-27T03:30:00.000000'"], {}], ["line", [">>> print(ts.select('weekday'))"], {}], ["line", ["'monday'"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["By extension, to get the following Monday, just add seven:"], {"indentation": 0}], ["syntax", [["line", ["ts = types.Timestamp.of(iso=\"2000-01-01T3:30:00\")"], {}], ["line", ["ts = ts.update('day', 8, 'week')"], {}], ["line", [">>> print(ts)"], {}], ["line", ["'2000-01-03T03:30:00.000000'"], {}], ["line", [">>> print(ts.select('weekday'))"], {}], ["line", ["'monday'"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Or, to get the preceding Monday, just substract seven:"], {"indentation": 0}], ["syntax", [["line", [">>> ts = types.Timestamp.of(iso=\"2000-01-01T3:30:00\")"], {}], ["line", [">>> ts = ts.update('day', 1-7, 'week')"], {}], ["line", [">>> print(ts)"], {}], ["line", ["1999-12-20T03:30:00.000000"], {}], ["line", [">>> print(ts.select('weekday'))"], {}], ["line", ["monday"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["And so on: ", ["literal", ["1+|-14"], {"cast": null}], ", ", ["literal", ["1+|-21"], {"cast": null}], ", ..."], {"indentation": 0}]], {"identifier": "Getting a Particular Day of the Week", "absolute": ["Arithmetic of Points and Measures", "Getting a Particular Day of the Week"], "selector-path": ["Getting a Particular Day of the Week"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["Occasionally, the need may arise to fetch the N-th weekday of the month. This is", " ", "trickier than getting an arbitrary weekday as it requires the part to be aligned", " ", "on a month. Given an arbitrary time type supporting gregorian units, ", ["literal", ["ts"], {"cast": null}], ", the", " ", "month must first be adjusted to the beginning of the month:"], {"indentation": null}], ["syntax", [["line", ["# Find the third Saturday of the month."], {}], ["line", ["ts = types.Timestamp.of(...)"], {}], ["line", [""], {}], ["line", ["# Get the first of the month."], {}], ["line", ["ts = ts.update('day', 0, 'month')"], {}], ["line", ["# Now the first Saturday of the month."], {}], ["line", ["ts = ts.update('day', 6, 'week')"], {}], ["line", ["ts.elapse(day=14)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["The above, however, is hiding a factor due to Saturday's nature of being on", " ", "the end of the week: alignment. Alignment allows the repositioning of the", " ", "boundary that a part is selected from or updated by. This provides the ability", " ", "to designate that a particular weekday be the beginning or end of the week.", " ", "Subsequently, allowing quick identification:"], {"indentation": 0}], ["syntax", [["line", ["ts = types.Timestamp.of(...)"], {}], ["line", ["# Get the last day of the Month."], {}], ["line", ["ts = ts.elapse(month=1).update('day', -1, 'month')"], {}], ["line", ["ts.update('day', 0, 'week', align=-2)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Getting a Particular Weekday of a Month", "absolute": ["Arithmetic of Points and Measures", "Getting a Particular Weekday of a Month"], "selector-path": ["Getting a Particular Weekday of a Month"], "selector-level": 1, "selector-multiple": null}]], {"identifier": "Arithmetic of Points and Measures", "absolute": ["Arithmetic of Points and Measures"], "selector-path": ["Arithmetic of Points and Measures"], "selector-level": null, "selector-multiple": null}], ["section", [["paragraph", ["Time zones are ", ["emphasis", ["difficult"], {"weight": "1"}], " to work with. In the best situations, use is not necessary, but that is,", " ", "unfortunately, not often. Time zones offer a rather unique problem as programmers are", " ", "indirectly forced into supporting designations often defined by local government. This", " ", "imposition complicates the situation dramatically. Even in the case where the right", " ", "process is followed, it is possible to come to the wrong conclusion given rotten time zone", " ", "information."], {"indentation": null}], ["paragraph", ["There is no easy mode when being time zone aware. It's an extra level of detail that", " ", "", ["emphasis", ["must"], {"weight": "1"}], " be managed by the application."], {"indentation": null}], ["section", [["paragraph", ["The difficulty of time zones stems from the need to transition to and from an", " ", "offset for appropriating the representation of a Point in Time. This is referring to", " ", "a couple tasks:"], {"indentation": null}], ["set", [["item", [["paragraph", ["Representing a UTC Point in Time in a local form."], {"indentation": null}]], {}], ["item", [["paragraph", ["Converting a local form to a UTC Point in Time."], {"indentation": null}]], {}]], {}], ["paragraph", ["While this is trivial on the face, the local form is actually a moving target. A", " ", "time zone database is maintained by a standards body in order to keep", " ", "track of how the local form varies. Often this involves daylight savings time,", " ", "but extends into situations where political decisions alter the offsets for a", " ", "given region altogether. At a wider scope the database ", ["emphasis", ["can"], {"weight": "1"}], " change entirely.", " ", "Consider database corrections, updates, or complete substitutions."], {"indentation": 0}], ["paragraph", ["This subjective offsetting can create situations where a given time of day", " ", "of a local form ", ["emphasis", ["is either ambiguous or invalid"], {"weight": "1"}], ". Proper handling of these cases", " ", "is often dependent on the context in which a given local form is being used."], {"indentation": null}], ["paragraph", ["When working with zoned PiTs, there are two situations:"], {"indentation": null}], ["sequence", [["item", [["paragraph", ["A canonical Point, normally a PiT in UTC associated with a zone."], {"indentation": null}]], {}], ["item", [["paragraph", ["A local Point where the local form is being represented."], {"indentation": null}]], {}]], {}], ["paragraph", ["Each situation has its own requirements for proper zone handling."], {"indentation": 0}], ["paragraph", ["In the first, the zone identifier should be associated with the PiT object.", " ", "These objects should always be a type capable of designating a date and time of", " ", "day, the ", ["reference", [".types.Timestamp"], {"source": ".types.Timestamp", "type": "normal", "action": null, "cast": null, "url": null}], " type. Representation types like", " ", "", ["reference", [".types.Date"], {"source": ".types.Date", "type": "normal", "action": null, "cast": null, "url": null}], " don't require zone adjustments unless it", " ", "is ultimately intended to refer to the beginning of the day in that particular", " ", "zone in UTC."], {"indentation": null}], ["paragraph", ["In the second, the actual offset ", ["emphasis", ["and"], {"weight": "1"}], " zone identifier applied to the zone", " ", "should be associated with the PiT object."], {"indentation": null}]], {"identifier": "Understanding Time Zones", "absolute": ["Working with Time Zones", "Understanding Time Zones"], "selector-path": ["Understanding Time Zones"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["While ", ["reference", [".views"], {"source": ".views", "type": "normal", "action": null, "cast": null, "url": null}], " provides the implementation of Zone objects, high level", " ", "access is provided via the ", ["reference", [".views.Zone.open"], {"source": ".views.Zone.open", "type": "normal", "action": null, "cast": null, "url": null}], " class method:"], {"indentation": null}], ["syntax", [["line", ["tz = views.Zone.open('America/Los_Angeles')"], {}], ["line", ["pit = system.utc()"], {}], ["line", ["offset = tz.find(pit)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Once the ", ["reference", [".views.Zone.Offset"], {"source": ".views.Zone.Offset", "type": "normal", "action": null, "cast": null, "url": null}], " object has been found for a given point in", " ", "time, the UTC point can be adjusted:"], {"indentation": 0}], ["syntax", [["line", ["la_pit = pit.elapse(offset)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Getting an Offset from a UTC Point in Time", "absolute": ["Working with Time Zones", "Getting an Offset from a UTC Point in Time"], "selector-path": ["Getting an Offset from a UTC Point in Time"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["The examples in the previous section show the details of localization.", " ", "", ["reference", [".views.Zone"], {"source": ".views.Zone", "type": "normal", "action": null, "cast": null, "url": null}], " instances have the above functionality packed into a", " ", "single method, ", ["reference", [".views.Zone.localize"], {"source": ".views.Zone.localize", "type": "normal", "action": null, "cast": null, "url": null}], ":"], {"indentation": null}], ["syntax", [["line", ["pit, offset = views.Zone.open().localize(system.utc())"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["The offset applied to the point in time is returned with the adjusted point as it is", " ", "often necessary in order to properly represent the timestamp:"], {"indentation": 0}], ["syntax", [["line", ["offset.iso(pit)"], {}], ["line", ["# \"2013-01-17T15:36:35.834813000 PST-28800\""], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}]], {"identifier": "Localizing a UTC Point in Time", "absolute": ["Working with Time Zones", "Localizing a UTC Point in Time"], "selector-path": ["Localizing a UTC Point in Time"], "selector-level": 1, "selector-multiple": null}], ["section", [["paragraph", ["Normalization is the process of adjusting a localized timestamp by its ", ["emphasis", ["known"], {"weight": "1"}], " offset into", " ", "a UTC timestamp and then localizing it. The ", ["reference", [".views.Zone.normalize"], {"source": ".views.Zone.normalize", "type": "normal", "action": null, "cast": null, "url": null}], "", " ", "method has this functionality:"], {"indentation": null}], ["syntax", [["line", ["pit, offset = views.Zone.open().localize(system.utc())"], {}], ["line", ["normalized_pit, new_offset = views.Zone.open().normalize(offset, pit)"], {}], ["line", [""], {}]], {"type": "python", "qualifier": null}], ["paragraph", ["Where ", ["literal", ["normalized_pit"], {"cast": null}], " and ", ["literal", ["new_offset"], {"cast": null}], " are the ", ["emphasis", ["exact"], {"weight": "1"}], " same objects if no change was", " ", "necessary."], {"indentation": 0}]], {"identifier": "Normalizing a Local Point in Time", "absolute": ["Working with Time Zones", "Normalizing a Local Point in Time"], "selector-path": ["Normalizing a Local Point in Time"], "selector-level": 1, "selector-multiple": null}]], {"identifier": "Working with Time Zones", "absolute": ["Working with Time Zones"], "selector-path": ["Working with Time Zones"], "selector-level": null, "selector-multiple": null}]], {}]], {}]