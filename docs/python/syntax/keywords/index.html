<html root="2"><head><title>fault.syntax.keywords</title><meta charset="utf-8"/><link as="style" rel="preload" href="../../.legacy-web/core.css"></link><link as="style" rel="preload" href="../../.legacy-web/factor.css"></link><link rel="stylesheet" href="../../.legacy-web/core.css"></link><link rel="stylesheet" href="../../.legacy-web/factor.css"></link></head><body><main><h1><span class="prefix"></span><div class="page-subject"><img class="icon" src="../../.factor-type-icon/if.fault.io/python-module.svg"></img><span class="subject-identifier">keywords</span><span class="element-status"><span class="misses">4</span><span class="completion-isolation"></span><span class="completion">97%</span></span><a href="http://if.fault.io/factors/python.module"><code class="type">python.module</code></a></div><div class="page-context"><a href="../"><img class="icon" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2Ij48dGV4dCB4PSI0IiB5PSIwLjg4ZW0iIGZvbnQtc2l6ZT0iMjQ4Ij7wn5OEPC90ZXh0Pjwvc3ZnPg=="></img></a><span class="context-identifier">fault.syntax</span></div></h1><section class="chapter"><p><span class="text.normal">Programming language profile and parser class for Keyword Oriented Syntax.</span></p><p><span class="text.normal">Provides a data structure for describing keyword based languages that allows</span><span class="text.line-break"> </span><span class="text.normal">a naive processor to assign classifications to the tokens contained</span><span class="text.line-break"> </span><span class="text.normal">by a string.</span></p><p><a class="factor-local" href="#Profile"><span class="class">Profile</span></a><span class="text.normal"> instances have limited information regarding languages and </span><a class="factor-local" href="#Parser"><span class="class">Parser</span></a><span class="text.normal"> instances should</span><span class="text.line-break"> </span><span class="text.normal">have naive processing algorithms. This intentional deficiency is a product of the goal to</span><span class="text.line-break"> </span><span class="text.normal">keep Keywords based interpretations trivial to implement and their parameter set small so that the</span><span class="text.line-break"> </span><span class="text.normal">the profile may be quickly and easily defined by users without requiring volumes of documentation</span><span class="text.line-break"> </span><span class="text.normal">to be consumed.</span></p></section><section class="unspecified" documented="true" local-identifier="Parser Process Methods" id="Parser-Process-Methods"><h1><span class="prefix"></span><a class="title" href="#Parser-Process-Methods"><span class="text.normal">Parser Process Methods</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><a class="factor-local" href="#Parser"><span class="class">Parser</span></a><span class="text.normal"> instances have two high-level methods for producing tokens: </span><a class="factor-local" href="#Parser.process_lines"><span class="method">Parser.process_lines</span></a><span class="text.normal"> and</span><span class="text.line-break"> </span><a class="factor-local" href="#Parser.process_document"><span class="method">Parser.process_document</span></a><span class="text.normal">. The former resets the context provided to </span><a class="factor-local" href="#Parser.delimit"><span class="method">Parser.delimit</span></a><span class="text.normal"> for each line,</span><span class="text.line-break"> </span><span class="text.normal">and the latter maintains it throughout the lifetime of the generator.</span></p><p><span class="text.normal">While </span><a class="factor-local" href="#Parser.process_document"><span class="method">Parser.process_document</span></a><span class="text.normal"> appears desireable in many cases, the limitations of </span><a class="factor-local" href="#Profile"><span class="class">Profile</span></a><span class="text.normal"> instances</span><span class="text.line-break"> </span><span class="text.normal">may make it reasonable to choose </span><a class="factor-local" href="#Parser.process_lines"><span class="method">Parser.process_lines</span></a><span class="text.normal"> in order to avoid the effects of an</span><span class="text.line-break"> </span><span class="text.normal">inaccruate profile or a language that maintains ambiguities with respect to the parser's capabilities.</span></p></section><section class="unspecified" documented="true" local-identifier="Engineering" id="Engineering"><h1><span class="prefix"></span><a class="title" href="#Engineering"><span class="text.normal">Engineering</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><span class="text.normal">Essentially, this is a lexer whose tokens are defined by </span><a class="factor-local" href="#Profile"><span class="class">Profile</span></a><span class="text.normal"> instances.</span><span class="text.line-break"> </span><span class="text.normal">The language types that are matches for applications are usually keyword based</span><span class="text.line-break"> </span><span class="text.normal">and leverage whitespace for isolation of fields.</span></p></section><section class="import" documented="false" local-identifier="typing" id="typing"><h1><span class="prefix"></span><a class="title" href="#typing"><span class="text.normal">typing</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type">import</span></div></h1></section><section class="import" documented="false" local-identifier="itertools" id="itertools"><h1><span class="prefix"></span><a class="title" href="#itertools"><span class="text.normal">itertools</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type">import</span></div></h1></section><section class="import" documented="false" local-identifier="functools" id="functools"><h1><span class="prefix"></span><a class="title" href="#functools"><span class="text.normal">functools</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type">import</span></div></h1></section><section class="import" documented="false" local-identifier="string" id="string"><h1><span class="prefix"></span><a class="title" href="#string"><span class="text.normal">string</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type">import</span></div></h1></section><section class="data" documented="false" local-identifier="Tokens" id="Tokens"><h1><span class="prefix"></span><a class="title" href="#Tokens"><span class="text.normal">Tokens</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type">data</span></div></h1><pre class="text.syntax"><code class="source">Tokens = typing.Iterable[typing.Tuple[str,str,str]]
</code></pre></section><section class="class" documented="true" local-identifier="Profile" id="Profile"><h1><span class="prefix"></span><a class="title" href="#Profile"><span class="text.normal">Profile</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">class</span></div></h1><div class="inheritance"><code class="type"><a class="invalid" href="#tuple"><span class="unknown">tuple</span></a></code></div><p><span class="text.normal">Data structure describing the elements of a Keyword Oriented Syntax.</span></p><p><span class="text.normal">Empty strings present in any of these sets will usually refer to the End of Line.</span><span class="text.line-break"> </span><span class="text.normal">This notation is primarily intended for area exclusions for supporting line comments,</span><span class="text.line-break"> </span><span class="text.normal">but </span><a class="factor-local" href="#Profile.literals"><span class="property">literals</span></a><span class="text.normal"> and </span><a class="factor-local" href="#Profile.enclosures"><span class="property">enclosures</span></a><span class="text.normal"> may also use them to represent the beginning or end of a line.</span></p><p><span class="text.normal">While </span><a class="factor-local" href="#Profile"><span class="class">Profile</span></a><span class="text.normal"> is a tuple subclass, indexes should </span><span class="text.emphasis">not</span><span class="text.normal"> be used to access members.</span></p><section class="data" documented="false" local-identifier="__slots__" id="Profile.__slots__"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.__slots__"><span class="text.normal">__slots__</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type">data</span></div></h1><pre class="text.syntax"><code class="source">__slots__ = ()
	@classmethod
</code></pre></section><section class="classmethod" documented="false" local-identifier="from_keywords_v1" id="Profile.from_keywords_v1"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.from_keywords_v1"><span class="text.normal">from_keywords_v1</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">classmethod</span></div></h1><p><code class="signature">from_keywords_v1(Class, **wordtypes)</code></p></section><section class="property" documented="true" local-identifier="words" id="Profile.words"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.words"><span class="text.normal">words</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">property</span></div><code class="type">typing.Mapping[str, typing.Set[str]]</code></h1><p><span class="text.normal">Dictionary associating sets of identifier strings with a classification identifier.</span></p></section><section class="property" documented="true" local-identifier="exclusions" id="Profile.exclusions"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.exclusions"><span class="text.normal">exclusions</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">property</span></div><code class="type">typing.Set[typing.Tuple[str,str]]</code></h1><p><span class="text.normal">Comment start and stop pairs delimiting an excluded area from the source.</span></p><p><span class="text.normal">Exclusions are given the second highest priority by </span><a class="factor-local" href="#Parser"><span class="class">Parser</span></a><span class="text.normal">.</span></p></section><section class="property" documented="true" local-identifier="literals" id="Profile.literals"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.literals"><span class="text.normal">literals</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">property</span></div><code class="type">typing.Set[typing.Tuple[str,str]]</code></h1><p><span class="text.normal">The start and stop pairs delimiting a literal area within the syntax document.</span><span class="text.line-break"> </span><span class="text.normal">Primarily used for string quotations, but supports distinct stops for</span><span class="text.line-break"> </span><span class="text.normal">handling other cases as well.</span></p><p><span class="text.normal">Literals are given the highest priority by </span><a class="factor-local" href="#Parser"><span class="class">Parser</span></a><span class="text.normal">.</span></p></section><section class="property" documented="true" local-identifier="enclosures" id="Profile.enclosures"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.enclosures"><span class="text.normal">enclosures</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">property</span></div><code class="type">typing.Set[typing.Tuple[str,str]]</code></h1><p><span class="text.normal">The start and stop pairs delimiting an expression.</span></p><p><span class="text.normal">Enclosures have the highest precedence during expression processing.</span></p></section><section class="property" documented="true" local-identifier="routers" id="Profile.routers"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.routers"><span class="text.normal">routers</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">property</span></div><code class="type">typing.Set[str]</code></h1><p><span class="text.normal">Operators used to designate a resolution path for selecting an object to be used.</span></p></section><section class="property" documented="true" local-identifier="operations" id="Profile.operations"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.operations"><span class="text.normal">operations</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">property</span></div><code class="type">typing.Set[str]</code></h1><p><span class="text.normal">Set of operators that can perform some manipulation to the objects associated</span><span class="text.line-break"> </span><span class="text.normal">with the adjacent identifiers.</span></p></section><section class="property" documented="true" local-identifier="terminators" id="Profile.terminators"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.terminators"><span class="text.normal">terminators</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">property</span></div><code class="type">typing.Set[str]</code></h1><p><span class="text.normal">Operators used to designate the end of a statement, expression, or field.</span></p></section><section class="property" documented="true" local-identifier="operators" id="Profile.operators"><h1><span class="prefix"></span><a class="section" href="#Profile">Profile</a><a class="title" href="#Profile.operators"><span class="text.normal">operators</span></a><span class="element-status"><span class="misses">2</span><span class="completion-isolation"></span><span class="completion">90%</span></span><div class="factor-element-meta"><span class="abstract-type">property</span></div><code class="type">typing.Iterable[str]</code></h1><p><span class="text.normal">Emit all unit operators employed by the language associated with a rank and context effect.</span><span class="text.line-break"> </span><span class="text.normal">Operators may appears multiple times. Empty strings represent end of line.</span></p><p><span class="text.normal">Operators are emitted by their classification in the following order:</span></p><ol class="text.sequence"><li><p><span class="text.normal">Operations</span></p></li><li><p><span class="text.normal">Routers</span></p></li><li><p><span class="text.normal">Terminators</span></p></li><li><p><span class="text.normal">Enclosures</span></p></li><li><p><span class="text.normal">Literals</span></p></li><li><p><span class="text.normal">Exclusions</span></p></li></ol><p><span class="text.normal">Order is deliberate in order to allow mappings to be directly built so</span><span class="text.line-break"> </span><span class="text.normal">later classes will overwrite earlier entries in cases of ambiguity.</span></p></section></section><section class="class" documented="true" local-identifier="Parser" id="Parser"><h1><span class="prefix"></span><a class="title" href="#Parser"><span class="text.normal">Parser</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">class</span></div></h1><div class="inheritance"><code class="type"><a class="invalid" href="#object"><span class="unknown">object</span></a></code></div><p><span class="text.normal">Keyword Oriented Syntax parser providing tokenization and region delimiting.</span></p><p><span class="text.normal">Instances do not hold state and methods of the same instance may be used</span><span class="text.line-break"> </span><span class="text.normal">by multiple threads.</span></p><section class="unspecified" documented="true" local-identifier="Engineering" id="Parser.Engineering"><h1 class="integrate"><span class="prefix"></span><a class="section" href="#Parser">Parser</a><a class="title" href="#Parser.Engineering"><span class="text.normal">Engineering</span></a><span class="element-status"></span><div class="factor-element-meta"><span class="abstract-type"></span></div></h1><p><span class="text.normal">This is essentially a tightly coupled partial application for </span><a class="factor-local" href="#Parser.tokenize"><span class="method">tokenize</span></a><span class="text.line-break"> </span><span class="text.normal">and </span><a class="factor-local" href="#Parser.delimit"><span class="method">delimit</span></a><span class="text.normal">. </span><a class="factor-local" href="#Parser.from_profile"><span class="classmethod">from_profile</span></a><span class="text.normal"> builds necessary parameters using a </span><a class="factor-local" href="#Profile"><span class="class">Profile</span></a><span class="text.line-break"> </span><span class="text.normal">instance and the internal constructor, </span><a class="factor-local" href="#Parser.__init__"><span class="method">__init__</span></a><span class="text.normal">, makes them available to the methods.</span></p><p><span class="text.normal">Applications should create and cache an instance for a given language.</span></p></section><section class="classmethod" documented="true" local-identifier="from_profile" id="Parser.from_profile"><h1><span class="prefix"></span><a class="section" href="#Parser">Parser</a><a class="title" href="#Parser.from_profile"><span class="text.normal">from_profile</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">classmethod</span></div></h1><p><code class="signature">from_profile(Class, profile)</code></p><p><span class="text.normal">Primary constructor for </span><a class="factor-local" href="#Parser"><span class="class">Parser</span></a><span class="text.normal">.</span></p><p><span class="text.normal">Instances should usually be cached when repeat use is expected as</span><span class="text.line-break"> </span><span class="text.normal">some amount of preparation is performed by </span><a class="factor-local" href="#Parser.from_profile"><span class="classmethod">from_profile</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="__init__" id="Parser.__init__"><h1><span class="prefix"></span><a class="section" href="#Parser">Parser</a><a class="title" href="#Parser.__init__"><span class="text.normal">__init__</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">method</span></div></h1><p><code class="signature">__init__(self, profile, opset, opmap, delimiter, optable, exits, classify_id, classify_op)</code></p><div class="admonition-WARNING"><table><tr><td><span class="admonition.icon"></span></td><td><span class="admonition.severity">WARNING</span></td></tr><tr><td></td><td><div class="admonition.content"><p><span class="text.normal">The initializer's parameters are subject to change.</span><span class="text.line-break"> </span><a class="factor-local" href="#Parser.from_profile"><span class="classmethod">from_profile</span></a><span class="text.normal"> should be used to build instances.</span></p></div></td></tr></table></div></section><section class="method" documented="true" local-identifier="process_lines" id="Parser.process_lines"><h1><span class="prefix"></span><a class="section" href="#Parser">Parser</a><a class="title" href="#Parser.process_lines"><span class="text.normal">process_lines</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">method</span></div><code class="type">typing.Iterable[typing.Iterable[Tokens]]</code></h1><p><code class="signature">process_lines(self, lines)</code></p><p><span class="text.normal">Process lines using context resets;</span><span class="text.line-break"> </span><a class="factor-local" href="#Parser.tokenize"><span class="method">tokenize</span></a><span class="text.normal"> and </span><a class="factor-local" href="#Parser.delimit"><span class="method">delimit</span></a><span class="text.normal"> multiple </span><a class="factor-local" href="#Parser.process_lines.Parameters.lines"><span class="parameter">lines</span></a><span class="text.normal"> resetting the context at the end of each line.</span></p><p><span class="text.normal">This is the recommended method for extracting tokens from a file for syntax documents</span><span class="text.line-break"> </span><span class="text.normal">that are expected to restate line context, have inaccurate profiles, or are incomplete.</span></p><p><span class="text.normal">The produced iterators may be ran out of order as no parsing state is shared across lines.</span></p></section><section class="method" documented="true" local-identifier="process_document" id="Parser.process_document"><h1><span class="prefix"></span><a class="section" href="#Parser">Parser</a><a class="title" href="#Parser.process_document"><span class="text.normal">process_document</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">method</span></div><code class="type">typing.Iterable[typing.Iterable[Tokens]]</code></h1><p><code class="signature">process_document(self, lines)</code></p><p><span class="text.normal">Process lines of a complete source code file using continuous context;</span><span class="text.line-break"> </span><a class="factor-local" href="#Parser.tokenize"><span class="method">tokenize</span></a><span class="text.normal"> and </span><a class="factor-local" href="#Parser.delimit"><span class="method">delimit</span></a><span class="text.normal"> multiple lines maintaining the context across all </span><a class="factor-local" href="#Parser.process_document.Parameters.lines"><span class="parameter">lines</span></a><span class="text.normal">.</span></p><p><span class="text.normal">This is the recommended method for extracting tokens from a file for syntax documents</span><span class="text.line-break"> </span><span class="text.normal">that are expected to </span><span class="text.emphasis">not</span><span class="text.normal"> restate line context </span><span class="text.emphasis">and</span><span class="text.normal"> have accurate profiles.</span></p><p><span class="text.normal">The produced iterators </span><span class="text.emphasis.heavy">must</span><span class="text.normal"> be ran in the produced order as the context is shared across</span><span class="text.line-break"> </span><span class="text.normal">instances.</span></p></section><section class="method" documented="true" local-identifier="allocstack" id="Parser.allocstack"><h1><span class="prefix"></span><a class="section" href="#Parser">Parser</a><a class="title" href="#Parser.allocstack"><span class="text.normal">allocstack</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">method</span></div></h1><p><code class="signature">allocstack(self)</code></p><p><span class="text.normal">Allocate context stack for use with </span><a class="factor-local" href="#Parser.delimit"><span class="method">delimit</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="delimit" id="Parser.delimit"><h1><span class="prefix"></span><a class="section" href="#Parser">Parser</a><a class="title" href="#Parser.delimit"><span class="text.normal">delimit</span></a><span class="element-status"><span class="misses">2</span><span class="completion-isolation"></span><span class="completion">95%</span></span><div class="factor-element-meta"><span class="abstract-type">method</span></div><code class="type"><a class="factor-local" href="#Tokens"><span class="data">Tokens</span></a></code></h1><p><code class="signature">delimit(self, context, tokens)</code></p><p><span class="text.normal">Insert switch tokens into an iteration of tokens marking the</span><span class="text.line-break"> </span><span class="text.normal">boundaries of expressions, comments and quotations.</span></p><p><a class="factor-local" href="#Parser.delimit.Parameters.context"><span class="parameter">context</span></a><span class="text.normal"> is manipulated during the iteration and maintains the</span><span class="text.line-break"> </span><span class="text.normal">nested state of comments. </span><a class="factor-local" href="#Parser.allocstack"><span class="method">allocstack</span></a><span class="text.normal"> may be used to allocate an</span><span class="text.line-break"> </span><span class="text.normal">initial state.</span></p><p><span class="text.normal">This is a relatively low-level method; </span><a class="factor-local" href="#Parser.process_lines"><span class="method">process_lines</span></a><span class="text.normal"> or </span><a class="factor-local" href="#Parser.process_document"><span class="method">process_document</span></a><span class="text.line-break"> </span><span class="text.normal">should normally be used.</span></p></section><section class="method" documented="true" local-identifier="tokenize" id="Parser.tokenize"><h1><span class="prefix"></span><a class="section" href="#Parser">Parser</a><a class="title" href="#Parser.tokenize"><span class="text.normal">tokenize</span></a><span class="element-status"><span class="nothing-missed">0</span></span><div class="factor-element-meta"><span class="abstract-type">method</span></div><code class="type"><a class="factor-local" href="#Tokens"><span class="data">Tokens</span></a></code></h1><p><code class="signature">tokenize(self, line)</code></p><p><span class="text.normal">Tokenize a string of syntax according to the profile.</span></p><p><span class="text.normal">Direct use of this is not recommended as boundaries are not signalled.</span><span class="text.line-break"> </span><a class="factor-local" href="#Parser.process_lines"><span class="method">process_lines</span></a><span class="text.normal"> or </span><a class="factor-local" href="#Parser.process_document"><span class="method">process_document</span></a><span class="text.normal"> should be used.</span><span class="text.line-break"> </span><span class="text.normal">The raw tokens, however, are usable in contexts where boundary information is</span><span class="text.line-break"> </span><span class="text.normal">not desired or is not accurate enough for an application's use.</span></p></section></section><h1 class="footing"></h1></main></body></html>