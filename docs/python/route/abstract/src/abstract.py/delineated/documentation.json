[["Route interface descriptions for &Path manipulations and &File system controls.", "", "[ File System Property Codes ]", "", "&File operations that analyze status properties use character codes to", "perform filtering. The codes listed here are primarily for POSIX filesystems", "and may have extensions or different meanings when used with emulated filesystems.", "", "[> Permissions]", "Character codes identifying available permissions.", "", "\t/`'r'`/", "\t\tReadable.", "\t/`'w'`/", "\t\tWritable.", "\t/`'x'`/", "\t\tExecutable or searchable.", "", "[> Types]", "Character codes identifying a type of file.", "", "\t/`'*'`/", "\t\tAny.", "\t/`'!'`/", "\t\tVoid; file must not exist.", "\t/`'/'`/", "\t\tDirectory.", "\t/`'.'`/", "\t\tData. A \"regular\" file.", "\t/`'&'`/", "\t\tA symbolic link.", "\t/`'|'`/", "\t\tA named pipe.", "\t/`'@'`/", "\t\tA file system socket file.", "\t/`'#'`/", "\t\tA device file.", "\t/`'?'`/", "\t\tUnknown type.", "\t\tFile exists, but it's type is not known and may be inaccessible."], ["Primitive operations for manipulating a sequence of identifiers."], ["The route containing the final identifier in &self."], ["The absolute sequence of identifiers."], ["The object identifying the resource relative to its immediate container.", "The last point in the route."], ["Construct a new route consisting of the existing sequence of points up to the *last*", "point specified by the &point argument. Similar to slicing a sequence from a", "reverse index search."], ["Stepwise root ascension.", "", "#!python", "\tassert list(~route) == [route ** 1, route ** 2, ..., route ** len(route)]"], ["Stepwise ascension path."], ["Stepwise descension path."], ["Stepwise traverse path."], ["Composite extension.", "Construct a new route by extending &self with the points expressed in &path.", "", "[ Parameters ]", "/path_expression/", "\tA string that represents a relative or absolute path."], ["Extension by iterable.", "Construct a new route by extending &self with &points.", "", "#!python", "\tassert (route + points) == (route / points[0] / points[1] ... / points[n])"], ["Segment extension.", "Construct a new route by extending &self with all the points in &route.", "", "#!python", "\tassert (route // segment) == (route + segment.absolute)"], ["Single extension.", "Construct a new route by extending &self with the sole &point.", "", "#!python", "\tassert (route / identifier) == (route + [identifier])"], ["Identifier substitution.", "Construct a new route by extending &self.container with &identifier.", "", "#!python", "\tassert (route * 'replacement') == (route.container / 'replacement')"], ["Numeric ascension operation.", "Construct a new route representing the &nth container of &self.", "", "#!python", "\tassert (route ** 1) == (route.container)", "\tassert (route ** 2) == (route.container.container)"], ["File system APIs for supporting common access functions."], ["Exception describing the property violations found", "by a call to &fs_require."], ["Check the file for the expressed requirements.", "The &properties string consists of characters described by", "&[File System Property Codes].", "", "[ Parameters ]", "/properties/", "\tThe required type, permissions and option control flags.", "/type/", "\tThe required file type, inclusive.", "\tWhen &None, the default, the file type must not be a directory.", "", "\tOverrides any file type codes present in &properties.", "", "[ Exceptions ]", "/&Violation/", "\tRaised when a designated property is not present on the file."], ["Destroy the existing file or directory, &self, and replace it with the", "file or directory at the given route, &replacement.", "", "[ Parameters ]", "/replacement/", "\tThe route to the file or directory that will be used to replace", "\tthe one at &self."], ["Destroy the file or directory at the location identified by &self.", "For directories, this recursively removes content as well."], ["Relocate the directory contents in &discarded into &self, and", "destroy the segment of directories between &self and &discarded.", "", "[ Returns ]", "&self"], ["Allocate the necessary resources to create the target path as a file or directory.", "", "Normally, this means creating the *leading* path to the identified resource."], ["Create or update a *symbolic* link at &self pointing to &path, the target file.", "The linked target path will be relative to &self' route.", "", "[ Parameters ]", "/path/", "\tThe route identifying the target path of the symbolic link."], ["Create or update a *symbolic* link at &self pointing to &path, the target file.", "The linked target path will be absolute.", "", "[ Parameters ]", "/path/", "\tThe route identifying the target path of the symbolic link."], ["Create a directory at the location referenced by &self."], ["Select the set of files contained within the directory identified by &self", "that match the required &properties.", "", "The &properties string consists of characters described by", "&[File System Property Codes]."], ["Identify the portion of the route that actually exists on the filesystem."], ["Identify the next non-linear directory.", "", "Recursively scan the filesystem until a directory is found containing", "zero files, more than one file, or a sole non-directory file is found.", "", "[ Returns ]", "The path to the next non-linear directory as a &File."], ["Construct a data structure representing the latest status of the file."], ["Update the status properties of the file identified by &self.", "If no arguments are supplied, not changes will be performed.", "", "[ Parameters ]", "/name/", "\tChange the identifier used to select the file relative to", "\tits parent directory.", "/size/", "\tAdjust the size of the file, truncating or zero-padding as needed.", "/modified/", "\tThe time that the file was said to be modified.", "/created/", "\tThe time that the file was said to be created."], ["Retrieve the binary data stored at the location identified by &self."], ["Store the given &data at the location referenced by &self."], ["A string identifying the type of file selected by the &Route.", "Often a shorthand for accessing the type from the structure", "returned by &fs_status."], ["Whether or not the regular file is executable.", "", "Directories marked as executable are not considered executables."], ["Whether or not the directory's listing can be retrieved.", "", "Regular files marked as executable are not considered searchable."], ["Construct an element tree of files from the directory identified by &self.", "", "Exceptions raised by operations populating the tree are trapped", "as `'exception'` elements that are filtered by &process by default.", "", "[ Parameters ]", "/process/", "\tBoolean callable determining whether or not a file should be included in the", "\tresulting element tree.", "", "\tDefaults to a function excluding `'exception'` types.", "/depth/", "\tThe maximum filesystem depth to descend from &self.", "\tIf &None, no depth constraint is enforced.", "\tDefaults to `8`.", "/limit/", "\tThe maximum number of elements to accumulate.", "\tIf &None, no limit constraint is enforced.", "\tDefaults to `2048`.", "", "[ Returns ]", "The sequence of elements that represent the directory's listing", "according to the given arguments."]]