[[["BranchNodes"], ["expression_mapping"], ["coverage_module_context"], ["count_boolop_expression"], ["count_call_expression"], ["profile_transaction"], ["profile_pause"]], [[{"syntax": "ast.BoolOp", "area": [[12, 2], [12, 11]]}, {"syntax": "ast.IfExp", "area": [[13, 2], [13, 10]]}], {"syntax": "{\n\tast.withitem: 'context_expr',\n\tast.comprehension: 'value',\n}", "area": [[16, 22], [19, 1]]}, {"syntax": "\"\"\"\nif True:\n\timport collections as _fi_cl\n\timport atexit as _fi_ae\n\timport functools as _fi_ft\n\timport os as _fi_os\n\n\t_fi_counters__ = _fi_cl.Counter()\n\t_fi_identity = _fi_os.environ.get('METRICS_IDENTITY') or ''\n\n\tdef _fi_record(counters=_fi_counters__, origin=_fi_identity, Retry=32):\n\t\timport sys, os, collections\n\n\t\tif 'PROCESS_IDENTITY' in os.environ:\n\t\t\tpid = os.environ['PROCESS_IDENTITY']\n\t\telse:\n\t\t\tpid = str(os.getpid())\n\n\t\tif 'METRICS_CAPTURE' in os.environ:\n\t\t\t# If capture is defined, qualify with the module name.\n\t\t\t# /../metrics/{pid}/{module}/{project}/{factor}/{test}/.fault-syntax-counters\n\t\t\tpath = os.environ['METRICS_CAPTURE']\n\t\t\tpath += '/coverage'\n\t\t\tpath += '/' + pid\n\t\t\tpath += '/' + __name__\n\t\telse:\n\t\t\ttry:\n\t\t\t\tif __metrics_trap__ is None:\n\t\t\t\t\t# No destination.\n\t\t\t\t\treturn\n\t\t\texcept NameError:\n\t\t\t\treturn\n\n\t\t\t# /../metrics/coverage/{pid}/{project}/{factor}/{test}/.fault-syntax-counters\n\t\t\t# Resolve __metrics_trap__ global at exit in order to allow the runtime\n\t\t\t# to designate it given compile time absence.\n\t\t\tpath = __metrics_trap__\n\t\t\tpath += '/coverage'\n\t\t\tpath += '/' + pid\n\n\t\tpath += '/' + os.environ.get('METRICS_IDENTITY', '.fault-python')\n\t\tpath += '/.fault-syntax-counters'\n\t\tfor x in range(Retry):\n\t\t\ttry:\n\t\t\t\tos.makedirs(path)\n\t\t\texcept FileExistsError:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tbreak\n\n\t\t# Vectorize the counters.\n\t\tevents = collections.defaultdict(list)\n\t\toccurrences = collections.defaultdict(list)\n\t\tfor (fp, area), v in counters.items():\n\t\t\tevents[fp].append(area)\n\t\t\toccurrences[fp].append(v)\n\n\t\t# Sequence the sources for an index.\n\t\t# The contents of the vectors will be emitted according to this list.\n\t\tsources = list(events.keys())\n\t\tsources.sort()\n\n\t\t# Index designating sources and the number of counters.\n\t\t# For Python, this will normally (always) be a single line.\n\t\t# Append as PROCESS_IDENTITY may be intentionally redundant.\n\t\twith open(path + '/sources', 'a') as f:\n\t\t\tf.writelines(['%d %s\\\\n' %(len(events[x]), x) for x in sources])\n\n\t\twith open(path + '/areas', 'a') as f:\n\t\t\tfor x in sources:\n\t\t\t\tf.writelines(['%d %d %d %d\\\\n' % k for k in events[x]])\n\n\t\twith open(path + '/counts', 'a') as f:\n\t\t\tfor x in sources:\n\t\t\t\tf.writelines(['%d\\\\n' %(c,) for c in occurrences[x]])\n\n\t_fi_ae.register(_fi_record)\n\n\ttry:\n\t\t_FI_INCREMENT__ = _fi_ft.partial(_fi_cl._count_elements, _fi_counters__)\n\texcept:\n\t\t_FI_INCREMENT__ = _fi_counters__.update\n\n\tdef _FI_COUNT__(area, rob, F=__file__, C=_FI_INCREMENT__):\n\t\tC(((F, area),))\n\t\treturn rob\n\n\t# Limit names left in the module globals.\n\tdel _fi_os, _fi_ft, _fi_cl, _fi_ae, _fi_record, _fi_identity\n\"\"\".strip() + '\\n'", "area": [[89, 27], [178, 18]]}, "(_FI_INCREMENT__(((__file__, %r),)) or INSTRUMENTATION_ERROR)", "_FI_COUNT__(%r,None)", "\nif True:\n\ttry:\n\t\t_FI_ENTER__(%r)\n\t\tpass\n\tfinally:\n\t\t_FI_EXIT__(%r)\n", "\nif True:\n\ttry:\n\t\t_FI_SUSPEND__(%r)\n\t\tpass\n\tfinally:\n\t\t_FI_CONTINUE__(%r)\n"]]