<html root="2"><head><title>terminal.cells.text</title><meta charset="utf-8"/><link as="style" rel="preload" href="../../.legacy-web/core.css"></link><link as="style" rel="preload" href="../../.legacy-web/factor.css"></link><link rel="stylesheet" href="../../.legacy-web/core.css"></link><link rel="stylesheet" href="../../.legacy-web/factor.css"></link></head><body><main><h1><span class="prefix"></span><div class="page-subject"><img class="icon" src="../../.factor-type-icon/if.fault.io/python-module.svg"></img><span class="subject-identifier">text</span><a href="http://if.fault.io/factors/python.module"><code class="type">python.module</code></a></div><div class="page-context"><a href="../"><img class="icon" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2Ij48dGV4dCB4PSI0IiB5PSIwLjg4ZW0iIGZvbnQtc2l6ZT0iMjQ4Ij7wn5WvPC90ZXh0Pjwvc3ZnPg=="></img></a><span class="context-identifier">terminal.cells</span></div></h1><section class="chapter"><p><span class="text.normal">Functions and types for representing text as cells.</span></p></section><section class="import" documented="false" local-identifier="operator" id="operator"><h1><span class="prefix"></span><a class="title" href="#operator"><span class="text.normal">operator</span></a><span class="abstract-type">import</span></h1></section><section class="import" documented="false" local-identifier="itertools" id="itertools"><h1><span class="prefix"></span><a class="title" href="#itertools"><span class="text.normal">itertools</span></a><span class="abstract-type">import</span></h1></section><section class="import" documented="false" local-identifier="functools" id="functools"><h1><span class="prefix"></span><a class="title" href="#functools"><span class="text.normal">functools</span></a><span class="abstract-type">import</span></h1></section><section class="import" documented="false" local-identifier="Iterable" id="Iterable"><h1><span class="prefix"></span><a class="title" href="#Iterable"><span class="text.normal">Iterable</span></a><span class="abstract-type">import</span></h1></section><section class="import" documented="false" local-identifier="Glyph" id="Glyph"><h1><span class="prefix"></span><a class="title" href="#Glyph"><span class="text.normal">Glyph</span></a><span class="abstract-type">import</span></h1></section><section class="function" documented="true" local-identifier="graphemes" id="graphemes"><h1><span class="prefix"></span><a class="title" href="#graphemes"><span class="text.normal">graphemes</span></a><span class="abstract-type">function</span></h1><p><code class="signature">graphemes(Cells, ci, ctlsize, tabsize)</code></p><p><span class="text.normal">Recognize Character Units from an iterator of codepoints using </span><a class="factor-local" href="#graphemes.Parameters.Cells"><span class="parameter">Cells</span></a><span class="text.normal">.</span></p><p><span class="text.normal">Identification of Character Units is performed by analyzing the cell usage of</span><span class="text.line-break"> </span><span class="text.normal">contiguous codepoints. When a change in cell usage occurs, presume that</span><span class="text.line-break"> </span><span class="text.normal">a new Character Unit has begun. However, do so while considering</span><span class="text.line-break"> </span><span class="text.normal">Variant Selector, ZWJ Sequence, and Regional Indicator exceptions.</span></p><div class="admonition-WARNING"><table><tr><td><span class="admonition.icon"></span></td><td><span class="admonition.severity">WARNING</span></td></tr><tr><td></td><td><div class="admonition.content"><p><span class="text.normal">ZWJ sequences are nearly presumed to be emoji sequences;</span><span class="text.line-break"> </span><span class="text.normal">the maximum cell count of the codepoints in the sequence determines</span><span class="text.line-break"> </span><span class="text.normal">the reported cells. While this may yield the correct alignment</span><span class="text.line-break"> </span><span class="text.normal">outside of emoji, there are cases where a join intends to represent</span><span class="text.line-break"> </span><span class="text.normal">two character units in which the identified maximum will be incorrect.</span></p></div></td></tr></table></div><section class="unspecified" documented="true" local-identifier="Parameters" id="graphemes.Parameters"><h1 class="integrate"><span class="prefix"></span><a class="section" href="#graphemes">graphemes</a><a class="title" href="#graphemes.Parameters"><span class="text.normal">Parameters</span></a><span class="abstract-type"></span></h1><dl class="text.mapping"><div id="graphemes.Parameters.Cells" class="parameter" documented="true"><dt><a class="dkn" href="#graphemes.Parameters.Cells"></a><span class="directory-key"><code class="parameter">Cells</code></span></dt><dd><div class="status"></div><p><span class="text.normal">The function identifying the width of a character.</span></p></dd></div><div id="graphemes.Parameters.ci" class="parameter" documented="true"><dt><a class="dkn" href="#graphemes.Parameters.ci"></a><span class="directory-key"><code class="parameter">ci</code></span></dt><dd><div class="status"></div><ul class="text.set"><li><p><code class="type.syntax">Iterable[str]</code></p></li></ul><p><span class="text.normal">Iterable of unicode characters.</span></p></dd></div><div id="graphemes.Parameters.ctlsize" class="parameter" documented="true"><dt><a class="dkn" href="#graphemes.Parameters.ctlsize"></a><span class="directory-key"><code class="parameter">ctlsize</code></span></dt><dd><div class="status"></div><p><span class="text.normal">Cell count to assign to low-ascii control characters.</span></p></dd></div><div id="graphemes.Parameters.tabsize" class="parameter" documented="true"><dt><a class="dkn" href="#graphemes.Parameters.tabsize"></a><span class="directory-key"><code class="parameter">tabsize</code></span></dt><dd><div class="status"></div><p><span class="text.normal">Cell count to assign to tab characters.</span></p></dd></div></dl></section><section class="unspecified" documented="true" local-identifier="Regional Indicators" id="graphemes.Regional-Indicators"><h1 class="integrate"><span class="prefix"></span><a class="section" href="#graphemes">graphemes</a><a class="title" href="#graphemes.Regional-Indicators"><span class="text.normal">Regional Indicators</span></a><span class="abstract-type"></span></h1><p><span class="text.normal">Currently uses range checks. If </span><code class="python.keyword">match</code><span class="text.normal"> ever implements</span><span class="text.line-break"> </span><span class="text.normal">jump tables for constants, the following template can be used to generate</span><span class="text.line-break"> </span><span class="text.normal">the or-list.</span></p><pre class="text.syntax"><code class="syntax/python">ri_offset = 0x1F1E6
ri_codes = [
	(hex((x - ord('a')) + ri_offset))[2:].upper()
	for x in range(ord('a'), ord('z'))
]
for p in ri_codes[0::4], ri_codes[1::4], ri_codes[2::4], ri_codes[3::4]:
	print('"' + '" | "\U000'.join(p) + '" | \')
</code></pre></section></section><section class="function" documented="true" local-identifier="words" id="words"><h1><span class="prefix"></span><a class="title" href="#words"><span class="text.normal">words</span></a><span class="abstract-type">function</span><code class="type">tuple[int, str]</code></h1><p><code class="signature">words(gi)</code></p><p><span class="text.normal">Group Character Units by the cell usage rate. Exceptions given to already plural</span><span class="text.line-break"> </span><span class="text.normal">strings which expect to be treated as units.</span></p><p><span class="text.normal">Processes the </span><a class="factor-local" href="#graphemes"><span class="function">graphemes</span></a><span class="text.normal"> generator into cell counts and string pairs providing</span><span class="text.line-break"> </span><span class="text.normal">the critical parameters for </span><a class="project-local" href="../types.Words"><span class="unknown">types.Words</span></a><span class="text.normal"> and </span><a class="project-local" href="../types.Unit"><span class="unknown">types.Unit</span></a><span class="text.normal"> instances.</span></p><section class="unspecified" documented="true" local-identifier="Parameters" id="words.Parameters"><h1 class="integrate"><span class="prefix"></span><a class="section" href="#words">words</a><a class="title" href="#words.Parameters"><span class="text.normal">Parameters</span></a><span class="abstract-type"></span></h1><dl class="text.mapping"><div id="words.Parameters.gi" class="parameter" documented="true"><dt><a class="dkn" href="#words.Parameters.gi"></a><span class="directory-key"><code class="parameter">gi</code></span></dt><dd><div class="status"></div><ul class="text.set"><li><p><code class="type.syntax">Iterable[tuple[str, int]]</code></p></li></ul><p><span class="text.normal">Iterator producing codepoint expression and cell count pairs.</span></p></dd></div></dl></section><section class="unspecified" documented="true" local-identifier="Returns" id="words.Returns"><h1 class="integrate"><span class="prefix"></span><a class="section" href="#words">words</a><a class="title" href="#words.Returns"><span class="text.normal">Returns</span></a><span class="abstract-type"></span></h1><p><span class="text.normal">Iterator of cells and strings where negative cell counts indicate a</span><span class="text.line-break"> </span><span class="text.normal">a sole Character Unit.</span></p><p><span class="text.normal">The integer and string positions are swapped in order to be consistent</span><span class="text.line-break"> </span><span class="text.normal">with </span><a class="project-local" href="../types.Words"><span class="unknown">types.Words</span></a><span class="text.normal"> order.</span></p></section></section><section class="class" documented="true" local-identifier="Words" id="Words"><h1><span class="prefix"></span><a class="title" href="#Words"><span class="text.normal">Words</span></a><span class="abstract-type">class</span></h1><div class="inheritance"><code class="type"><a class="invalid" href="#tuple"><span class="unknown">tuple</span></a></code></div><p><a class="factor-local" href="#Phrase"><span class="class">Phrase</span></a><span class="text.normal"> segments identifying the cell count of the word text</span><span class="text.line-break"> </span><span class="text.normal">and the </span><a class="project-local" href="../types.Glyph"><span class="project-factor">terminal.cells.types.Glyph</span></a><span class="text.normal"> frame that should be used to style the text.</span></p><section class="data" documented="false" local-identifier="__slots__" id="Words.__slots__"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.__slots__"><span class="text.normal">__slots__</span></a><span class="abstract-type">data</span></h1><pre class="text.syntax"><code class="source">__slots__ = ()
	@property
</code></pre></section><section class="property" documented="true" local-identifier="unit" id="Words.unit"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.unit"><span class="text.normal">unit</span></a><span class="abstract-type">property</span><code class="type"><a class="invalid" href="#int"><span class="unknown">int</span></a></code></h1><p><span class="text.normal">The codepoints per character units.</span><span class="text.line-break"> </span><span class="text.normal">Normally </span><code class="">1</code><span class="text.normal">. Codepoint length for </span><a class="factor-local" href="#Unit"><span class="class">Unit</span></a><span class="text.normal"> and </span><a class="factor-local" href="#Redirect"><span class="class">Redirect</span></a><span class="text.normal">.</span></p></section><section class="property" documented="true" local-identifier="cellrate" id="Words.cellrate"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.cellrate"><span class="text.normal">cellrate</span></a><span class="abstract-type">property</span><code class="type"><a class="invalid" href="#int"><span class="unknown">int</span></a></code></h1><p><span class="text.normal">Number of cells required to display a </span><span class="text.emphasis">character unit</span><span class="text.normal"> of the word text.</span></p></section><section class="data" documented="false" local-identifier="text" id="Words.text"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.text"><span class="text.normal">text</span></a><span class="abstract-type">data</span></h1><pre class="text.syntax"><code class="source">text = property(operator.itemgetter(1))
</code></pre></section><section class="method" documented="false" local-identifier="render" id="Words.render"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.render"><span class="text.normal">render</span></a><span class="abstract-type">method</span></h1><p><code class="signature">render(self)</code></p></section><section class="property" documented="true" local-identifier="style" id="Words.style"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.style"><span class="text.normal">style</span></a><span class="abstract-type">property</span><code class="type"><a class="project-local" href="../types.Glyph"><span class="project-factor">Glyph</span></a></code></h1><p><span class="text.normal">The traits and colors to use when rendering the text.</span></p></section><section class="method" documented="true" local-identifier="split" id="Words.split"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.split"><span class="text.normal">split</span></a><span class="abstract-type">method</span></h1><p><code class="signature">split(self, whence)</code></p><p><span class="text.normal">Split the word at the given codepoint offset, </span><a class="factor-local" href="#Words.split.Parameters.whence"><span class="parameter">whence</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="cellcount" id="Words.cellcount"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.cellcount"><span class="text.normal">cellcount</span></a><span class="abstract-type">method</span><code class="type"><a class="invalid" href="#int"><span class="unknown">int</span></a></code></h1><p><code class="signature">cellcount(self)</code></p><p><span class="text.normal">Number of cells required to display the word text.</span></p><p><span class="text.normal">This measurement is stored alongside of the string that will be rendered.</span><span class="text.line-break"> </span><span class="text.normal">It is possible, if not likely, that this override be respected above</span><span class="text.line-break"> </span><span class="text.normal">a system's </span><code class="">wcswidth</code><span class="text.normal"> implementation.</span></p></section><section class="method" documented="true" local-identifier="celloffset" id="Words.celloffset"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.celloffset"><span class="text.normal">celloffset</span></a><span class="abstract-type">method</span><code class="type"><a class="invalid" href="#int"><span class="unknown">int</span></a></code></h1><p><code class="signature">celloffset(self, offset)</code></p><p><span class="text.normal">Translate word relative codepoint offset to word relative cell offset.</span></p></section><section class="method" documented="true" local-identifier="cellpoint" id="Words.cellpoint"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.cellpoint"><span class="text.normal">cellpoint</span></a><span class="abstract-type">method</span></h1><p><code class="signature">cellpoint(self, celloffset)</code></p><p><span class="text.normal">Translate the word relative </span><a class="factor-local" href="#Words.cellpoint.Parameters.celloffset"><span class="parameter">celloffset</span></a><span class="text.normal"> to the word relative codepoint offset.</span></p></section><section class="method" documented="true" local-identifier="unitcount" id="Words.unitcount"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.unitcount"><span class="text.normal">unitcount</span></a><span class="abstract-type">method</span><code class="type"><a class="invalid" href="#int"><span class="unknown">int</span></a></code></h1><p><code class="signature">unitcount(self)</code></p><p><span class="text.normal">The number of character units in the </span><a class="invalid" href="#codepoints"><span class="unknown">codepoints</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="unitoffset" id="Words.unitoffset"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.unitoffset"><span class="text.normal">unitoffset</span></a><span class="abstract-type">method</span><code class="type"><a class="invalid" href="#int"><span class="unknown">int</span></a></code></h1><p><code class="signature">unitoffset(self, offset)</code></p><p><span class="text.normal">Translate word relative codepoint offset to word relative character unit offset.</span></p></section><section class="method" documented="true" local-identifier="unitpoint" id="Words.unitpoint"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.unitpoint"><span class="text.normal">unitpoint</span></a><span class="abstract-type">method</span></h1><p><code class="signature">unitpoint(self, unitoffset)</code></p><p><span class="text.normal">Translate word relative Character Unit offset into word relative codepoint offset.</span></p></section><section class="method" documented="true" local-identifier="codecount" id="Words.codecount"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.codecount"><span class="text.normal">codecount</span></a><span class="abstract-type">method</span></h1><p><code class="signature">codecount(self)</code></p><p><span class="text.normal">Number of codepoints used to represent the words' text.</span></p><p><span class="text.normal">This is equivalent to </span><code class="">len(Words(...).text)</code><span class="text.normal">, but</span><span class="text.line-break"> </span><span class="text.normal">offers a point of abstraction in, very unlikely, implementation changes.</span></p></section><section class="method" documented="true" local-identifier="codeoffset" id="Words.codeoffset"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.codeoffset"><span class="text.normal">codeoffset</span></a><span class="abstract-type">method</span></h1><p><code class="signature">codeoffset(self, codeoffset)</code></p><p><span class="text.normal">The codepoint offset; returns </span><a class="factor-local" href="#Words.codeoffset.Parameters.codeoffset"><span class="parameter">codeoffset</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="codepoint" id="Words.codepoint"><h1><span class="prefix"></span><a class="section" href="#Words">Words</a><a class="title" href="#Words.codepoint"><span class="text.normal">codepoint</span></a><span class="abstract-type">method</span></h1><p><code class="signature">codepoint(self, codeoffset)</code></p><p><span class="text.normal">Translate the word relative </span><a class="factor-local" href="#Words.codepoint"><span class="method">codepoint</span></a><span class="text.normal"> offset to the word relative codepoint offset.</span><span class="text.line-break"> </span><span class="text.normal">A reflective mapping, but bind the returned offset to the word's range returning</span><span class="text.line-break"> </span><span class="text.normal">overflow or underflow as the remainder.</span></p></section></section><section class="class" documented="true" local-identifier="Unit" id="Unit"><h1><span class="prefix"></span><a class="title" href="#Unit"><span class="text.normal">Unit</span></a><span class="abstract-type">class</span></h1><div class="inheritance"><code class="type"><a class="factor-local" href="#Words"><span class="class">Words</span></a></code></div><p><span class="text.normal">Words representing a single character unit composed from a</span><span class="text.line-break"> </span><span class="text.normal">unicode codepoint expression. Expressions being regional indicator</span><span class="text.line-break"> </span><span class="text.normal">pairs, emoji ZWJ sequences, and Variant Selector qualified codepoints.</span></p><p><span class="text.normal">Unit words provides the necessary compensation for inconsistent </span><a class="factor-local" href="#Words.cellrate"><span class="property">Words.cellrate</span></a><span class="text.normal">.</span></p><section class="data" documented="false" local-identifier="__slots__" id="Unit.__slots__"><h1><span class="prefix"></span><a class="section" href="#Unit">Unit</a><a class="title" href="#Unit.__slots__"><span class="text.normal">__slots__</span></a><span class="abstract-type">data</span></h1><pre class="text.syntax"><code class="source">__slots__ = ()
</code></pre></section><section class="method" documented="false" local-identifier="render" id="Unit.render"><h1><span class="prefix"></span><a class="section" href="#Unit">Unit</a><a class="title" href="#Unit.render"><span class="text.normal">render</span></a><span class="abstract-type">method</span></h1><p><code class="signature">render(self)</code></p></section><section class="property" documented="false" local-identifier="unit" id="Unit.unit"><h1><span class="prefix"></span><a class="section" href="#Unit">Unit</a><a class="title" href="#Unit.unit"><span class="text.normal">unit</span></a><span class="abstract-type">property</span><code class="type"><a class="invalid" href="#int"><span class="unknown">int</span></a></code></h1></section><section class="method" documented="true" local-identifier="split" id="Unit.split"><h1><span class="prefix"></span><a class="section" href="#Unit">Unit</a><a class="title" href="#Unit.split"><span class="text.normal">split</span></a><span class="abstract-type">method</span></h1><p><code class="signature">split(self, offset)</code></p><p><span class="text.normal">Maintain </span><a class="factor-local" href="#Words.split"><span class="method">Words.split</span></a><span class="text.normal"> interface, but always return a tuple with a sole element.</span></p></section></section><section class="class" documented="true" local-identifier="Redirect" id="Redirect"><h1><span class="prefix"></span><a class="title" href="#Redirect"><span class="text.normal">Redirect</span></a><span class="abstract-type">class</span></h1><div class="inheritance"><code class="type"><a class="factor-local" href="#Unit"><span class="class">Unit</span></a></code></div><p><span class="text.normal">A </span><a class="factor-local" href="#Unit"><span class="class">Unit</span></a><span class="text.normal"> that explicitly remaps its display text.</span><span class="text.line-break"> </span><span class="text.normal">Used to control the transmitted representations of control characters and indentation.</span></p><section class="data" documented="false" local-identifier="text" id="Redirect.text"><h1><span class="prefix"></span><a class="section" href="#Redirect">Redirect</a><a class="title" href="#Redirect.text"><span class="text.normal">text</span></a><span class="abstract-type">data</span></h1><pre class="text.syntax"><code class="source">text = property(operator.itemgetter(3))
</code></pre></section><section class="method" documented="false" local-identifier="render" id="Redirect.render"><h1><span class="prefix"></span><a class="section" href="#Redirect">Redirect</a><a class="title" href="#Redirect.render"><span class="text.normal">render</span></a><span class="abstract-type">method</span></h1><p><code class="signature">render(self)</code></p></section></section><section class="class" documented="true" local-identifier="Phrase" id="Phrase"><h1><span class="prefix"></span><a class="title" href="#Phrase"><span class="text.normal">Phrase</span></a><span class="abstract-type">class</span></h1><div class="inheritance"><code class="type"><a class="invalid" href="#tuple"><span class="unknown">tuple</span></a></code></div><p><span class="text.normal">A sequence </span><a class="factor-local" href="#Words"><span class="class">Words</span></a><span class="text.normal"> providing translation interfaces for codepoints, cells, and character</span><span class="text.line-break"> </span><span class="text.normal">units.</span></p><section class="data" documented="false" local-identifier="__slots__" id="Phrase.__slots__"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.__slots__"><span class="text.normal">__slots__</span></a><span class="abstract-type">data</span></h1><pre class="text.syntax"><code class="source">__slots__ = ()
</code></pre></section><section class="method" documented="true" local-identifier="render" id="Phrase.render"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.render"><span class="text.normal">render</span></a><span class="abstract-type">method</span></h1><p><code class="signature">render(self)</code></p><p><span class="text.normal">Generate the cells that would represent the words of the phrase.</span></p></section><section class="staticmethod" documented="true" local-identifier="frame_word" id="Phrase.frame_word"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.frame_word"><span class="text.normal">frame_word</span></a><span class="abstract-type">staticmethod</span></h1><p><code class="signature">frame_word(cf, cells, text)</code></p><p><span class="text.normal">Select the appropriate </span><a class="factor-local" href="#Words"><span class="class">Words</span></a><span class="text.normal"> class for containing the </span><a class="factor-local" href="#Phrase.frame_word.Parameters.text"><span class="parameter">text</span></a><span class="text.normal">.</span><span class="text.line-break"> </span><span class="text.normal">Order of parameters is intended to support </span><a class="factor-local" href="#Phrase.from_segmentation"><span class="classmethod">from_segmentation</span></a><span class="text.normal">.</span></p></section><section class="classmethod" documented="false" local-identifier="segment" id="Phrase.segment"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.segment"><span class="text.normal">segment</span></a><span class="abstract-type">classmethod</span></h1><p><code class="signature">segment(Class, qwords)</code></p></section><section class="data" documented="false" local-identifier="m_unit" id="Phrase.m_unit"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.m_unit"><span class="text.normal">m_unit</span></a><span class="abstract-type">data</span></h1><pre class="text.syntax"><code class="source">m_unit = (
	Words.unitcount,
	Words.unitoffset,
	Words.unitpoint,
)
</code></pre></section><section class="data" documented="false" local-identifier="m_cell" id="Phrase.m_cell"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.m_cell"><span class="text.normal">m_cell</span></a><span class="abstract-type">data</span></h1><pre class="text.syntax"><code class="source">m_cell = (
	Words.cellcount,
	Words.celloffset,
	Words.cellpoint,
)
</code></pre></section><section class="data" documented="false" local-identifier="m_codepoint" id="Phrase.m_codepoint"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.m_codepoint"><span class="text.normal">m_codepoint</span></a><span class="abstract-type">data</span></h1><pre class="text.syntax"><code class="source">m_codepoint = (
	Words.codecount,
	Words.codeoffset,
	Words.codepoint,
)
	@property
</code></pre></section><section class="property" documented="true" local-identifier="text" id="Phrase.text"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.text"><span class="text.normal">text</span></a><span class="abstract-type">property</span><code class="type"><a class="invalid" href="#str"><span class="unknown">str</span></a></code></h1><p><span class="text.normal">The text content of the phrase.</span><span class="text.line-break"> </span><span class="text.normal">May not be consistent with what is sent to a display in </span><a class="factor-local" href="#Redirect"><span class="class">Redirect</span></a><span class="text.normal"> cases.</span></p></section><section class="classmethod" documented="true" local-identifier="wordspace" id="Phrase.wordspace"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.wordspace"><span class="text.normal">wordspace</span></a><span class="abstract-type">classmethod</span></h1><p><code class="signature">wordspace(Class)</code></p><p><span class="text.normal">Word specification consisting of a single space.</span></p></section><section class="classmethod" documented="false" local-identifier="from_words" id="Phrase.from_words"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.from_words"><span class="text.normal">from_words</span></a><span class="abstract-type">classmethod</span></h1><p><code class="signature">from_words(Class, *words)</code></p></section><section class="classmethod" documented="false" local-identifier="from_segmentation" id="Phrase.from_segmentation"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.from_segmentation"><span class="text.normal">from_segmentation</span></a><span class="abstract-type">classmethod</span></h1><p><code class="signature">from_segmentation(Class, qwords)</code></p></section><section class="method" documented="true" local-identifier="join" id="Phrase.join"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.join"><span class="text.normal">join</span></a><span class="abstract-type">method</span></h1><p><code class="signature">join(self, phrases)</code></p><p><span class="text.normal">Create a new Phrase from </span><a class="factor-local" href="#Phrase.join.Parameters.phrases"><span class="parameter">phrases</span></a><span class="text.normal"> by placing </span><a class="factor-local" href="#Phrase.join.Parameters.self"><span class="parameter">self</span></a><span class="text.normal"> between each </span><a class="factor-local" href="#Phrase"><span class="class">Phrase</span></a><span class="text.normal"> instance</span><span class="text.line-break"> </span><span class="text.normal">in </span><a class="factor-local" href="#Phrase.join.Parameters.phrases"><span class="parameter">phrases</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="combine" id="Phrase.combine"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.combine"><span class="text.normal">combine</span></a><span class="abstract-type">method</span></h1><p><code class="signature">combine(self)</code></p><p><span class="text.normal">Combine word specifications with identical attributes(styles).</span><span class="text.line-break"> </span><span class="text.normal">Returns a new </span><a class="factor-local" href="#Phrase"><span class="class">Phrase</span></a><span class="text.normal"> instance with any redundant word attributes eliminated.</span></p></section><section class="method" documented="true" local-identifier="cellcount" id="Phrase.cellcount"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.cellcount"><span class="text.normal">cellcount</span></a><span class="abstract-type">method</span></h1><p><code class="signature">cellcount(self)</code></p><p><span class="text.normal">Number of cells that the phrase will occupy.</span></p></section><section class="method" documented="true" local-identifier="unitcount" id="Phrase.unitcount"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.unitcount"><span class="text.normal">unitcount</span></a><span class="abstract-type">method</span></h1><p><code class="signature">unitcount(self)</code></p><p><span class="text.normal">Number of character units contained by the phrase.</span></p></section><section class="method" documented="true" local-identifier="reverse" id="Phrase.reverse"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.reverse"><span class="text.normal">reverse</span></a><span class="abstract-type">method</span></h1><p><code class="signature">reverse(self)</code></p><p><span class="text.normal">Construct an iterator to the concrete words for creating a new </span><a class="factor-local" href="#Phrase"><span class="class">Phrase</span></a><span class="text.line-break"> </span><span class="text.normal">instance that is in reversed form of the words in </span><a class="factor-local" href="#Phrase.reverse.Parameters.self"><span class="parameter">self</span></a><span class="text.normal">.</span><span class="text.line-break"> </span><code class="">assert phrase == Phrase(Phrase(phrase.reverse()).reverse())</code></p></section><section class="method" documented="true" local-identifier="subphrase" id="Phrase.subphrase"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.subphrase"><span class="text.normal">subphrase</span></a><span class="abstract-type">method</span></h1><p><code class="signature">subphrase(self, start, stop)</code></p><p><span class="text.normal">Extract the subphrase at the given cell offsets.</span></p></section><section class="method" documented="true" local-identifier="select" id="Phrase.select"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.select"><span class="text.normal">select</span></a><span class="abstract-type">method</span></h1><p><code class="signature">select(self, start, stop, adjust)</code></p><p><span class="text.normal">Extract the subphrase at the given indexes.</span></p><section class="unspecified" documented="true" local-identifier="Parameters" id="Phrase.select.Parameters"><h1 class="integrate"><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="section" href="#Phrase.select">select</a><a class="title" href="#Phrase.select.Parameters"><span class="text.normal">Parameters</span></a><span class="abstract-type"></span></h1><dl class="text.mapping"><div id="Phrase.select.Parameters.self" class="parameter" documented="false"><dt><a class="dkn" href="#Phrase.select.Parameters.self"></a><span class="directory-key"><code class="parameter">self</code></span></dt><dd><div class="status"></div><p><code class="control.absent">Undocumented</code><span class="text.normal">.</span></p></dd></div><div id="Phrase.select.Parameters.start" class="parameter" documented="false"><dt><a class="dkn" href="#Phrase.select.Parameters.start"></a><span class="directory-key"><code class="parameter">start</code></span></dt><dd><div class="status"></div><p><code class="control.absent">Undocumented</code><span class="text.normal">.</span></p></dd></div><div id="Phrase.select.Parameters.stop" class="parameter" documented="false"><dt><a class="dkn" href="#Phrase.select.Parameters.stop"></a><span class="directory-key"><code class="parameter">stop</code></span></dt><dd><div class="status"></div><p><code class="control.absent">Undocumented</code><span class="text.normal">.</span></p></dd></div><div id="Phrase.select.Parameters.adjust" class="parameter" documented="true"><dt><a class="dkn" href="#Phrase.select.Parameters.adjust"></a><span class="directory-key"><code class="parameter">adjust</code></span></dt><dd><div class="status"></div><p><span class="text.normal">Callable that changes the text properties of the selected words.</span><span class="text.line-break"> </span><span class="text.normal">Defaults to no change.</span></p></dd></div></dl></section></section><section class="method" documented="true" local-identifier="seek" id="Phrase.seek"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.seek"><span class="text.normal">seek</span></a><span class="abstract-type">method</span></h1><p><code class="signature">seek(self, whence, offset)</code></p><p><span class="text.normal">Find the word offset and codepoint offset for the unit </span><a class="factor-local" href="#Phrase.seek.Parameters.offset"><span class="parameter">offset</span></a><span class="text.line-break"> </span><span class="text.normal">relative to </span><a class="factor-local" href="#Phrase.seek.Parameters.whence"><span class="parameter">whence</span></a><span class="text.normal">.</span><span class="text.line-break"> </span><span class="text.normal">The </span><a class="factor-local" href="#Phrase.seek.Parameters.offset"><span class="parameter">offset</span></a><span class="text.normal"> is traversed using </span><a class="factor-local" href="#Phrase.seek.Parameters.ulength"><span class="parameter">ulength</span></a><span class="text.normal">, </span><a class="factor-local" href="#Phrase.seek.Parameters.uoffset"><span class="parameter">uoffset</span></a><span class="text.normal">, and </span><a class="invalid" href="#uindex"><span class="unknown">uindex</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="afirst" id="Phrase.afirst"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.afirst"><span class="text.normal">afirst</span></a><span class="abstract-type">method</span></h1><p><code class="signature">afirst(self, position)</code></p><p><span class="text.normal">Align the position to the beginning of the next word given</span><span class="text.line-break"> </span><span class="text.normal">that the character index is at the end of the word</span><span class="text.line-break"> </span><span class="text.normal">and that there is a following word. If realignment is not</span><span class="text.line-break"> </span><span class="text.normal">possible, return </span><a class="factor-local" href="#Phrase.afirst.Parameters.position"><span class="parameter">position</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="alast" id="Phrase.alast"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.alast"><span class="text.normal">alast</span></a><span class="abstract-type">method</span></h1><p><code class="signature">alast(self, position)</code></p><p><span class="text.normal">Align the position to the end of the previous word given</span><span class="text.line-break"> </span><span class="text.normal">that the character index is at the start of the word</span><span class="text.line-break"> </span><span class="text.normal">and that there is a previous word. If realignment is not</span><span class="text.line-break"> </span><span class="text.normal">possible, return </span><a class="factor-local" href="#Phrase.alast.Parameters.position"><span class="parameter">position</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="split" id="Phrase.split"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.split"><span class="text.normal">split</span></a><span class="abstract-type">method</span></h1><p><code class="signature">split(self, whence)</code></p><p><span class="text.normal">Split the phrase at the given position, </span><a class="factor-local" href="#Phrase.split.Parameters.whence"><span class="parameter">whence</span></a><span class="text.normal">.</span></p></section><section class="method" documented="true" local-identifier="tell" id="Phrase.tell"><h1><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="title" href="#Phrase.tell"><span class="text.normal">tell</span></a><span class="abstract-type">method</span></h1><p><code class="signature">tell(self, position)</code></p><p><span class="text.normal">Identify the absolute unit offset for the given phrase position.</span></p><section class="unspecified" documented="true" local-identifier="Parameters" id="Phrase.tell.Parameters"><h1 class="integrate"><span class="prefix"></span><a class="section" href="#Phrase">Phrase</a><a class="section" href="#Phrase.tell">tell</a><a class="title" href="#Phrase.tell.Parameters"><span class="text.normal">Parameters</span></a><span class="abstract-type"></span></h1><dl class="text.mapping"><div id="Phrase.tell.Parameters.self" class="parameter" documented="false"><dt><a class="dkn" href="#Phrase.tell.Parameters.self"></a><span class="directory-key"><code class="parameter">self</code></span></dt><dd><div class="status"></div><p><code class="control.absent">Undocumented</code><span class="text.normal">.</span></p></dd></div><div id="Phrase.tell.Parameters.position" class="parameter" documented="true"><dt><a class="dkn" href="#Phrase.tell.Parameters.position"></a><span class="directory-key"><code class="parameter">position</code></span></dt><dd><div class="status"></div><p><span class="text.normal">The Word-Codepoint offset pair being described.</span></p></dd></div><div id="Phrase.tell.Parameters.ulength" class="parameter" documented="false"><dt><a class="dkn" href="#Phrase.tell.Parameters.ulength"></a><span class="directory-key"><code class="parameter">ulength</code></span></dt><dd><div class="status"></div><p><code class="control.absent">Undocumented</code><span class="text.normal">.</span></p></dd></div><div id="Phrase.tell.Parameters.uoffset" class="parameter" documented="false"><dt><a class="dkn" href="#Phrase.tell.Parameters.uoffset"></a><span class="directory-key"><code class="parameter">uoffset</code></span></dt><dd><div class="status"></div><p><code class="control.absent">Undocumented</code><span class="text.normal">.</span></p></dd></div><div id="Phrase.tell.Parameters.utranslate" class="parameter" documented="false"><dt><a class="dkn" href="#Phrase.tell.Parameters.utranslate"></a><span class="directory-key"><code class="parameter">utranslate</code></span></dt><dd><div class="status"></div><p><code class="control.absent">Undocumented</code><span class="text.normal">.</span></p></dd></div><div id="Phrase.tell.Parameters.sum" class="parameter" documented="false"><dt><a class="dkn" href="#Phrase.tell.Parameters.sum"></a><span class="directory-key"><code class="parameter">sum</code></span></dt><dd><div class="status"></div><p><code class="control.absent">Undocumented</code><span class="text.normal">.</span></p></dd></div><div id="Phrase.tell.Parameters.range" class="parameter" documented="false"><dt><a class="dkn" href="#Phrase.tell.Parameters.range"></a><span class="directory-key"><code class="parameter">range</code></span></dt><dd><div class="status"></div><p><code class="control.absent">Undocumented</code><span class="text.normal">.</span></p></dd></div></dl></section></section></section><h1 class="footing"></h1></main></body></html>